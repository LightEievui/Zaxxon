{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Zaxxon  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Zaxxon}
{\comment Generated by doxygen 1.10.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Zaxxon}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Animation\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Background\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Entity\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AbstractBullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
BossBullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CharacterBullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ObstacleBullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Boss\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Character\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Enemy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Player\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Obstacle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ZapWall\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Game\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GUI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
sf::Sprite
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
HMSection\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Wall\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ZaxxonText\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b AbstractBullet} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to hold information that the other bullets share })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Animation} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle (almost) all in-game animations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Background} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds all backgrounds and methods to fill each level with content })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Boss} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The boss entity you fight at the end of the level loop })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b BossBullet} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The missile that the boss shoots })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Character} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to hold information that both player and enemy use })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CharacterBullet} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet used by the player and enemies })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Enemy} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enemy} in the game. These use a recolored player bullet })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Entity} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class for all entities in the game })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Game} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main game and all related classes eventually end up being used here. {\b Game} loop is in here and is the 'heart' of the whole program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GUI} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all {\b GUI} used in the game, including all text. These are simple but can take a lot of space due to how much there is. Different GUIs are split into different render functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b HMSection} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The height meter and related methods })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Obstacle} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Still obstacles that spawn across the levels })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ObstacleBullet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Player} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The player character, also contains plane controls })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Wall} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for the normal walls (stone brick) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZapWall} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for other walls (blue lightning) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZaxxonText} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to grab text sprites from spritesheet given char or string })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Zaxxon/src/{\b Zaxxon.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Animation/{\b Animation.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Animation/{\b Animation.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Background/{\b Background.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Background/{\b Background.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/{\b Entity.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/{\b Entity.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/{\b AbstractBullet.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/{\b AbstractBullet.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/{\b BossBullet.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/{\b BossBullet.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/{\b CharacterBullet.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/{\b CharacterBullet.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/{\b ObstacleBullet.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/{\b ObstacleBullet.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Boss/{\b Boss.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Boss/{\b Boss.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/{\b Character.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/{\b Character.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/Enemy/{\b Enemy.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/Enemy/{\b Enemy.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/Player/{\b Player.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Entity/Character/Player/{\b Player.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Game/{\b Game.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Game/{\b Game.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/{\b GUI.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/{\b GUI.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/HMSection/{\b HMSection.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/HMSection/{\b HMSection.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/ZaxxonText/{\b ZaxxonText.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/GUI/ZaxxonText/{\b ZaxxonText.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Obstacle/{\b Obstacle.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Obstacle/{\b Obstacle.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Util/{\b Util.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Util/{\b Util.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Wall/{\b Wall.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/Wall/{\b Wall.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/ZapWall/{\b ZapWall.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Zaxxon/src/ZapWall/{\b ZapWall.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AbstractBullet Class Reference\par \pard\plain 
{\tc\tcl2 \v AbstractBullet}
{\xe \v AbstractBullet}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to hold information that the other bullets share. }}\par
{
{\f2 #include <AbstractBullet.h>}}\par
Inheritance diagram for AbstractBullet:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_abstract_bullet.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BulletType} \{ {\b Player}
, {\b Enemy}
, {\b Missile}
, {\b zBullet}
, {\b xBulletL}
, {\b xBulletR}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AbstractBullet} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the bullet is dead or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translate} (float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move a certain amount on the Z axis. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} (sf::RenderWindow &, float)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alive} = true\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to hold information that the other bullets share. \par
}{
Definition at line {\b 8} of file {\b AbstractBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v BulletType\:AbstractBullet}
{\xe \v AbstractBullet\:BulletType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b AbstractBullet::BulletType}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Player\:AbstractBullet}
{\xe \v AbstractBullet\:Player}
{\qr Player{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{\cell }{\row }
{\xe \v Enemy\:AbstractBullet}
{\xe \v AbstractBullet\:Enemy}
{\qr Enemy{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{\cell }{\row }
{\xe \v Missile\:AbstractBullet}
{\xe \v AbstractBullet\:Missile}
{\qr Missile{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\cell }{\cell }{\row }
{\xe \v zBullet\:AbstractBullet}
{\xe \v AbstractBullet\:zBullet}
{\qr zBullet{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{\cell }{\row }
{\xe \v xBulletL\:AbstractBullet}
{\xe \v AbstractBullet\:xBulletL}
{\qr xBulletL{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{\cell }{\row }
{\xe \v xBulletR\:AbstractBullet}
{\xe \v AbstractBullet\:xBulletR}
{\qr xBulletR{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 11} of file {\b AbstractBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AbstractBullet\:AbstractBullet}
{\xe \v AbstractBullet\:AbstractBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AbstractBullet::AbstractBullet (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b AbstractBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isHit\:AbstractBullet}
{\xe \v AbstractBullet\:isHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AbstractBullet::isHit ()}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the bullet is dead or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 8} of file {\b AbstractBullet.cpp}.}\par
}
{\xe \v translate\:AbstractBullet}
{\xe \v AbstractBullet\:translate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AbstractBullet::translate (float  {\i movement})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move a certain amount on the Z axis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i movement} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b AbstractBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v alive\:AbstractBullet}
{\xe \v AbstractBullet\:alive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AbstractBullet::alive = true{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b AbstractBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/{\b AbstractBullet.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/{\b AbstractBullet.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Animation Class Reference\par \pard\plain 
{\tc\tcl2 \v Animation}
{\xe \v Animation}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle (almost) all in-game animations. }}\par
{
{\f2 #include <Animation.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Anim} \{ {\b CHARACTER_DEATH}
, {\b ALT_DEATH}
, {\b LAUNCH}
, {\b BULLET_DEATH}
, {\b WALLBULLET_DEATH}
, {\b ROCKET_FLICKER}
, {\b RESET}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initalize individual animation frames. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Animation} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory for animation class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} (sf::Sprite *, {\b Anim}, unsigned int sizeIndex=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the given animation on sprite. Note that you should always check if the sprite* is null before doing operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getState} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if current animation has finished running. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle (almost) all in-game animations. \par
}{
Definition at line {\b 10} of file {\b Animation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Anim\:Animation}
{\xe \v Animation\:Anim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Animation::Anim}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CHARACTER_DEATH\:Animation}
{\xe \v Animation\:CHARACTER_DEATH}
{\qr CHARACTER_DEATH{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\cell }{\cell }{\row }
{\xe \v ALT_DEATH\:Animation}
{\xe \v Animation\:ALT_DEATH}
{\qr ALT_DEATH{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\cell }{\cell }{\row }
{\xe \v LAUNCH\:Animation}
{\xe \v Animation\:LAUNCH}
{\qr LAUNCH{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\cell }{\cell }{\row }
{\xe \v BULLET_DEATH\:Animation}
{\xe \v Animation\:BULLET_DEATH}
{\qr BULLET_DEATH{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\cell }{\cell }{\row }
{\xe \v WALLBULLET_DEATH\:Animation}
{\xe \v Animation\:WALLBULLET_DEATH}
{\qr WALLBULLET_DEATH{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\cell }{\cell }{\row }
{\xe \v ROCKET_FLICKER\:Animation}
{\xe \v Animation\:ROCKET_FLICKER}
{\qr ROCKET_FLICKER{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\cell }{\cell }{\row }
{\xe \v RESET\:Animation}
{\xe \v Animation\:RESET}
{\qr RESET{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 13} of file {\b Animation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Animation\:Animation}
{\xe \v Animation\:Animation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Animation::Animation ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initalize individual animation frames. }}\par
{
Definition at line {\b 7} of file {\b Animation.cpp}.}\par
}
{\xe \v ~Animation\:Animation}
{\xe \v Animation\:~Animation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Animation::~Animation ()}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory for animation class. }}\par
{
Definition at line {\b 58} of file {\b Animation.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getState\:Animation}
{\xe \v Animation\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Animation::getState () const}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if current animation has finished running. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 315} of file {\b Animation.cpp}.}\par
}
{\xe \v run\:Animation}
{\xe \v Animation\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Animation::run (sf::Sprite *  {\i sprite}, {\b Anim}  {\i anim}, unsigned int  {\i sizeIndex} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the given animation on sprite. Note that you should always check if the sprite* is null before doing operations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sprite} \cell }{Nullable\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i anim} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 74} of file {\b Animation.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Animation/{\b Animation.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Animation/{\b Animation.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Background Class Reference\par \pard\plain 
{\tc\tcl2 \v Background}
{\xe \v Background}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds all backgrounds and methods to fill each level with content. }}\par
{
{\f2 #include <Background.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Stage} \{ {\b INITIAL} = 0
, {\b SPACE} = 1
, {\b BOSS} = 2
, {\b BOSSFIGHT} = 3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Background} ({\b Stage}, sf::View &, sf::Texture *, std::vector< {\b Obstacle} * > &, std::vector< {\b Enemy} * > &, {\b Player} &, int, std::vector< {\b Wall} * > &, std::vector< {\b ZapWall} * > &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create the background object and initialize each of the necessary images so they are ready to be drawn when needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Background} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, sf::View &, float, sf::Texture *, std::vector< {\b Obstacle} * > &, std::vector< {\b Enemy} * > &, {\b Player} &, std::vector< {\b Wall} * > &, std::vector< {\b ZapWall} * > &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the background logic, and check if background stage should be swapped. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (sf::Vector2f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the position of the background. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generateObstacles} ({\b Stage}, std::vector< {\b Obstacle} * > &, sf::Texture *, std::vector< {\b Wall} * > &, std::vector< {\b ZapWall} * > &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Place all obstacles for given stage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generateWaves} ({\b Stage}, std::vector< {\b Enemy} * > &, sf::Texture *, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle enemy wave generation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetPos} (sf::View &, {\b Player} &, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the position of the background for stage changes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stage} {\b getStage} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current stage background is on. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStage} ({\b Stage})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the current stage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSpace} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if background is currently space, this affects the player. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b flashColor} (sf::RenderWindow &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash color of background between the default color and red tinted color based on state variable passed into the method. 0 is red, 1 is default. This is used for the first part of the death animation in {\b Game.cpp}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds all backgrounds and methods to fill each level with content. \par
}{
Definition at line {\b 15} of file {\b Background.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Stage\:Background}
{\xe \v Background\:Stage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Background::Stage}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v INITIAL\:Background}
{\xe \v Background\:INITIAL}
{\qr INITIAL{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\cell }{\cell }{\row }
{\xe \v SPACE\:Background}
{\xe \v Background\:SPACE}
{\qr SPACE{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\cell }{\cell }{\row }
{\xe \v BOSS\:Background}
{\xe \v Background\:BOSS}
{\qr BOSS{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\cell }{\cell }{\row }
{\xe \v BOSSFIGHT\:Background}
{\xe \v Background\:BOSSFIGHT}
{\qr BOSSFIGHT{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 18} of file {\b Background.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Background\:Background}
{\xe \v Background\:Background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Background::Background ({\b Stage}  {\i startStage}, sf::View &  {\i mainView}, sf::Texture *  {\i spritesheet}, std::vector< {\b Obstacle} * > &  {\i obstacles}, std::vector< {\b Enemy} * > &  {\i enemies}, {\b Player} &  {\i player}, int  {\i startPos}, std::vector< {\b Wall} * > &  {\i walls}, std::vector< {\b ZapWall} * > &  {\i zapWalls})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create the background object and initialize each of the necessary images so they are ready to be drawn when needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startStage} \cell }{Stage that {\b Background} will start on.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mainView} \cell }{The 3d view.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritesheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i obstacles} \cell }{{\b Obstacle} list.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enemies} \cell }{{\b Enemy} list.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i player} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPos} \cell }{The Z the background should go to at start.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i walls} \cell }{{\b Wall} list.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zapWalls} \cell }{Zap wall list.\cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b Background.cpp}.}\par
}
{\xe \v ~Background\:Background}
{\xe \v Background\:~Background}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Background::~Background ()}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b Background.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v flashColor\:Background}
{\xe \v Background\:flashColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::flashColor (sf::RenderWindow &  {\i window})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flash color of background between the default color and red tinted color based on state variable passed into the method. 0 is red, 1 is default. This is used for the first part of the death animation in {\b Game.cpp}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 663} of file {\b Background.cpp}.}\par
}
{\xe \v generateObstacles\:Background}
{\xe \v Background\:generateObstacles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::generateObstacles ({\b Stage}  {\i stage}, std::vector< {\b Obstacle} * > &  {\i obstacles}, sf::Texture *  {\i spriteSheet}, std::vector< {\b Wall} * > &  {\i walls}, std::vector< {\b ZapWall} * > &  {\i zapWalls})}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Place all obstacles for given stage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stage} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i obstacles} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 253} of file {\b Background.cpp}.}\par
}
{\xe \v generateWaves\:Background}
{\xe \v Background\:generateWaves}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::generateWaves ({\b Stage}  {\i stage}, std::vector< {\b Enemy} * > &  {\i enemies}, sf::Texture *  {\i spriteSheet}, int  {\i playerZ})}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle enemy wave generation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stage} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enemies} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i playerZ} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 608} of file {\b Background.cpp}.}\par
}
{\xe \v getStage\:Background}
{\xe \v Background\:getStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Background::Stage} Background::getStage ()}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current stage background is on. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A background stage\par
}}}{
Definition at line {\b 651} of file {\b Background.cpp}.}\par
}
{\xe \v isInSpace\:Background}
{\xe \v Background\:isInSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Background::isInSpace (int  {\i z})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if background is currently space, this affects the player. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i z} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 188} of file {\b Background.cpp}.}\par
}
{\xe \v resetPos\:Background}
{\xe \v Background\:resetPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::resetPos (sf::View &  {\i mainView}, {\b Player} &  {\i player}, int  {\i startPos})}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the position of the background for stage changes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mainView} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i player} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPos} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 217} of file {\b Background.cpp}.}\par
}
{\xe \v setPosition\:Background}
{\xe \v Background\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::setPosition (sf::Vector2f  {\i pos})}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the position of the background. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 124} of file {\b Background.cpp}.}\par
}
{\xe \v setStage\:Background}
{\xe \v Background\:setStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::setStage ({\b Stage}  {\i newStage})}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the current stage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newStage} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 673} of file {\b Background.cpp}.}\par
}
{\xe \v update\:Background}
{\xe \v Background\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Background::update (sf::RenderWindow &  {\i window}, sf::View &  {\i mainView}, float  {\i gameSpeed}, sf::Texture *  {\i spritesheet}, std::vector< {\b Obstacle} * > &  {\i obstacles}, std::vector< {\b Enemy} * > &  {\i enemies}, {\b Player} &  {\i player}, std::vector< {\b Wall} * > &  {\i walls}, std::vector< {\b ZapWall} * > &  {\i zapWalls})}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the background logic, and check if background stage should be swapped. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mainView} \cell }{3d View\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gameSpeed} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritesheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i obstacles} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enemies} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i player} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i walls} \cell }{{\b Wall} list.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zapWalls} \cell }{Zap wall list.\cell }
{\row }
}
}{
Definition at line {\b 66} of file {\b Background.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Background/{\b Background.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Background/{\b Background.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Boss Class Reference\par \pard\plain 
{\tc\tcl2 \v Boss}
{\xe \v Boss}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The boss entity you fight at the end of the level loop. }}\par
{
{\f2 #include <Boss.h>}}\par
Inheritance diagram for Boss:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_boss.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Boss} (sf::Vector3f, {\b Entity} *, sf::Texture *, sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepare the boss variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Boss} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the boss. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float gameSpeed) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for the boss each frame and then draw it to the screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run visual effects and code for when you land a hit on the boss. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BossBullet} * {\b getMissile} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the boss missile separately. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b missileCreated} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the boss missile exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDestroyed} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the boss has been defeated. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The boss entity you fight at the end of the level loop. \par
}{
Definition at line {\b 11} of file {\b Boss.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Boss\:Boss}
{\xe \v Boss\:Boss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boss::Boss (sf::Vector3f  {\i start}, {\b Entity} *  {\i target}, sf::Texture *  {\i bossSheet}, sf::Texture *  {\i spriteSheet})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepare the boss variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i start} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i target} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bossSheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Boss.cpp}.}\par
}
{\xe \v ~Boss\:Boss}
{\xe \v Boss\:~Boss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boss::~Boss (){\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the boss. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
 \par
}{
Definition at line {\b 40} of file {\b Boss.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getMissile\:Boss}
{\xe \v Boss\:getMissile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BossBullet} * Boss::getMissile () const}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the boss missile separately. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The missile as a BossBullet*\par
}}}{
Definition at line {\b 161} of file {\b Boss.cpp}.}\par
}
{\xe \v hit\:Boss}
{\xe \v Boss\:hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Boss::hit ()}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run visual effects and code for when you land a hit on the boss. }}\par
{
Definition at line {\b 139} of file {\b Boss.cpp}.}\par
}
{\xe \v isDestroyed\:Boss}
{\xe \v Boss\:isDestroyed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Boss::isDestroyed () const}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the boss has been defeated. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 181} of file {\b Boss.cpp}.}\par
}
{\xe \v missileCreated\:Boss}
{\xe \v Boss\:missileCreated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Boss::missileCreated () const}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the boss missile exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 171} of file {\b Boss.cpp}.}\par
}
{\xe \v update\:Boss}
{\xe \v Boss\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Boss::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for the boss each frame and then draw it to the screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 50} of file {\b Boss.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Boss/{\b Boss.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Boss/{\b Boss.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BossBullet Class Reference\par \pard\plain 
{\tc\tcl2 \v BossBullet}
{\xe \v BossBullet}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The missile that the boss shoots. }}\par
{
{\f2 #include <BossBullet.h>}}\par
Inheritance diagram for BossBullet:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_boss_bullet.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BossBullet} (sf::Vector3f, {\b Entity} *, sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a boss bullet based on it's position. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run logic for boss bullet then draw it to screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b damage} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrease the health of the bullet. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collide} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the death animation and set to dead. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AbstractBullet} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the bullet is dead or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translate} (float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move a certain amount on the Z axis. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Types inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BulletType} \{ {\b Player}
, {\b Enemy}
, {\b Missile}
, {\b zBullet}
, {\b xBulletL}
, {\b xBulletR}
 \}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alive} = true\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The missile that the boss shoots. \par
}{
Definition at line {\b 10} of file {\b BossBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BossBullet\:BossBullet}
{\xe \v BossBullet\:BossBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BossBullet::BossBullet (sf::Vector3f  {\i startPos}, {\b Entity} *  {\i target}, sf::Texture *  {\i spriteSheet})}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a boss bullet based on it's position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i target} \cell }{The entity that the missile is targetting.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b BossBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v collide\:BossBullet}
{\xe \v BossBullet\:collide}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BossBullet::collide ()}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the death animation and set to dead. }}\par
{
Definition at line {\b 69} of file {\b BossBullet.cpp}.}\par
}
{\xe \v damage\:BossBullet}
{\xe \v BossBullet\:damage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BossBullet::damage (int  {\i hit})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrease the health of the bullet. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hit} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 84} of file {\b BossBullet.cpp}.}\par
}
{\xe \v update\:BossBullet}
{\xe \v BossBullet\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BossBullet::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run logic for boss bullet then draw it to screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 33} of file {\b BossBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/{\b BossBullet.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/{\b BossBullet.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Character Class Reference\par \pard\plain 
{\tc\tcl2 \v Character}
{\xe \v Character}
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to hold information that both player and enemy use. }}\par
{
{\f2 #include <Character.h>}}\par
Inheritance diagram for Character:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_character.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Character} (sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new character who will have sprite from spritesheet. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Character} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the {\b Character} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move the character by velocity and redraw them to the screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > & {\b getBullets} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the currently fired bullets from this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSizeIndex} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b killBullet} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of bullet by index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position for the character itself. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _getSizeIndex} (unsigned int &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the height sector that character is in. Underscore infront indicates that it is not public. 0-3 3 indicates smallest, 0 indicates biggest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getVelocity} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the velocity of character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVelocity} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change the velocity of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBullet} (sf::IntRect)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change how the bullets from this character look. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateBullets} (sf::RenderWindow &window, float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b CharacterBullet::update()} on each bullet & deletes bullets that are not in the window. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMax} = 140\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMin} = 69\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMin} = -160\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMax} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b velocity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > {\b bullets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sizeIndex}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to hold information that both player and enemy use. \par
}{
Definition at line {\b 12} of file {\b Character.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Character\:Character}
{\xe \v Character\:Character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Character::Character (sf::Texture *  {\i spriteSheet})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new character who will have sprite from spritesheet. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 8} of file {\b Character.cpp}.}\par
}
{\xe \v ~Character\:Character}
{\xe \v Character\:~Character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Character::~Character (){\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the {\b Character} class. }}\par
{
Definition at line {\b 19} of file {\b Character.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v _getSizeIndex\:Character}
{\xe \v Character\:_getSizeIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::_getSizeIndex (unsigned int &  {\i planeSizeIndex}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the height sector that character is in. Underscore infront indicates that it is not public. 0-3 3 indicates smallest, 0 indicates biggest. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i planeSizeIndex} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 76} of file {\b Character.cpp}.}\par
}
{\xe \v getBullets\:Character}
{\xe \v Character\:getBullets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b CharacterBullet} * > & Character::getBullets ()}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the currently fired bullets from this character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector of bullets\par
}}}{
Definition at line {\b 54} of file {\b Character.cpp}.}\par
}
{\xe \v getSizeIndex\:Character}
{\xe \v Character\:getSizeIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Character::getSizeIndex () const}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 64} of file {\b Character.cpp}.}\par
}
{\xe \v getVelocity\:Character}
{\xe \v Character\:getVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector3f Character::getVelocity () const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the velocity of character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
sf::Vector3f\par
}}}{
Definition at line {\b 97} of file {\b Character.cpp}.}\par
}
{\xe \v kill\:Character}
{\xe \v Character\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Character::kill (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b Enemy} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Player} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v killBullet\:Character}
{\xe \v Character\:killBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::killBullet (int  {\i bullet})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of bullet by index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bullet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 150} of file {\b Character.cpp}.}\par
}
{\xe \v setBullet\:Character}
{\xe \v Character\:setBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::setBullet (sf::IntRect  {\i bulletTexture}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change how the bullets from this character look. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bulletTexture} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 107} of file {\b Character.cpp}.}\par
}
{\xe \v setPos\:Character}
{\xe \v Character\:setPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::setPos (sf::Vector3f  {\i pos})}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position for the character itself. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 161} of file {\b Character.cpp}.}\par
}
{\xe \v setVelocity\:Character}
{\xe \v Character\:setVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::setVelocity (sf::Vector3f  {\i vel}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change the velocity of this character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vel} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 117} of file {\b Character.cpp}.}\par
}
{\xe \v update\:Character}
{\xe \v Character\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move the character by velocity and redraw them to the screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b Enemy} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 31} of file {\b Character.cpp}.}\par
}
{\xe \v updateBullets\:Character}
{\xe \v Character\:updateBullets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Character::updateBullets (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b CharacterBullet::update()} on each bullet & deletes bullets that are not in the window. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{Main render window\cell }
{\row }
}
}{
Definition at line {\b 128} of file {\b Character.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bullets\:Character}
{\xe \v Character\:bullets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b CharacterBullet}*> Character::bullets{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b Character.h}.}\par
}
{\xe \v sizeIndex\:Character}
{\xe \v Character\:sizeIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Character::sizeIndex{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Character.h}.}\par
}
{\xe \v velocity\:Character}
{\xe \v Character\:velocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector3f Character::velocity{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Character.h}.}\par
}
{\xe \v xMax\:Character}
{\xe \v Character\:xMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Character::xMax = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Character.h}.}\par
}
{\xe \v xMin\:Character}
{\xe \v Character\:xMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Character::xMin = -160{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Character.h}.}\par
}
{\xe \v yMax\:Character}
{\xe \v Character\:yMax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Character::yMax = 140{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Character.h}.}\par
}
{\xe \v yMin\:Character}
{\xe \v Character\:yMin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Character::yMin = 69{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Character.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/{\b Character.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/{\b Character.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CharacterBullet Class Reference\par \pard\plain 
{\tc\tcl2 \v CharacterBullet}
{\xe \v CharacterBullet}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet used by the player and enemies. }}\par
{
{\f2 #include <CharacterBullet.h>}}\par
Inheritance diagram for CharacterBullet:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_character_bullet.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BulletDeathType} \{ {\b WallDeath}
, {\b EnemyDeath}
, {\b MissileDeath}
 \}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Types inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BulletType} \{ {\b Player}
, {\b Enemy}
, {\b Missile}
, {\b zBullet}
, {\b xBulletL}
, {\b xBulletR}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CharacterBullet} (sf::Texture *spritesheet, sf::Vector3f spawnPos, unsigned int sizeindex, {\b BulletType}={\b Player}, sf::Vector2f=sf::Vector2f(0, 0))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a bullet based on if player or enemy shot it. Players use 3f & enemies use 2f, enemies run on 2f space while players are on 3f space and it's not possible to convert from 2f to 3f, so enemies have to pass their 2f position to the bullets. Just make sure to pass the 2f if an enemy and the 3f will be ignored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kill} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default kill, run the kill method with enemyDeath as parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kill} ({\b BulletDeathType} type)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet hit something, run code to kill bullet based on what it hit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &window, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this bullet and then draw it to screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSizeIndex} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character bullet. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AbstractBullet} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the bullet is dead or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translate} (float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move a certain amount on the Z axis. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alive} = true\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet used by the player and enemies. \par
}{
Definition at line {\b 9} of file {\b CharacterBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v BulletDeathType\:CharacterBullet}
{\xe \v CharacterBullet\:BulletDeathType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b CharacterBullet::BulletDeathType}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v WallDeath\:CharacterBullet}
{\xe \v CharacterBullet\:WallDeath}
{\qr WallDeath{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\cell }{\cell }{\row }
{\xe \v EnemyDeath\:CharacterBullet}
{\xe \v CharacterBullet\:EnemyDeath}
{\qr EnemyDeath{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\cell }{\cell }{\row }
{\xe \v MissileDeath\:CharacterBullet}
{\xe \v CharacterBullet\:MissileDeath}
{\qr MissileDeath{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 12} of file {\b CharacterBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CharacterBullet\:CharacterBullet}
{\xe \v CharacterBullet\:CharacterBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CharacterBullet::CharacterBullet (sf::Texture *  {\i spritesheet}, sf::Vector3f  {\i spawnPos}, unsigned int  {\i sizeIndex}, {\b BulletType}  {\i type} = {\f2 {\b Player}}, sf::Vector2f  {\i spawnPos2f} = {\f2 sf::Vector2f(0,\~ 0)})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a bullet based on if player or enemy shot it. Players use 3f & enemies use 2f, enemies run on 2f space while players are on 3f space and it's not possible to convert from 2f to 3f, so enemies have to pass their 2f position to the bullets. Just make sure to pass the 2f if an enemy and the 3f will be ignored. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritesheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spawnPos} \cell }{Ignored if spawnPos2f is defined.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sizeIndex} \cell }{Size of bullet.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spawnPos2f} \cell }{Optional, pass through when enemy.\cell }
{\row }
}
}{
Definition at line {\b 16} of file {\b CharacterBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSizeIndex\:CharacterBullet}
{\xe \v CharacterBullet\:getSizeIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CharacterBullet::getSizeIndex ()}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character bullet. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 49} of file {\b CharacterBullet.cpp}.}\par
}
{\xe \v kill\:CharacterBullet}
{\xe \v CharacterBullet\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CharacterBullet::kill ()}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default kill, run the kill method with enemyDeath as parameter. }}\par
{
Definition at line {\b 58} of file {\b CharacterBullet.cpp}.}\par
}
{\xe \v kill\:CharacterBullet}
{\xe \v CharacterBullet\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CharacterBullet::kill ({\b BulletDeathType}  {\i deathType})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet hit something, run code to kill bullet based on what it hit. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deathType} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 68} of file {\b CharacterBullet.cpp}.}\par
}
{\xe \v update\:CharacterBullet}
{\xe \v CharacterBullet\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CharacterBullet::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this bullet and then draw it to screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 93} of file {\b CharacterBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/{\b CharacterBullet.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/{\b CharacterBullet.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Enemy Class Reference\par \pard\plain 
{\tc\tcl2 \v Enemy}
{\xe \v Enemy}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enemy} in the game. These use a recolored player bullet. }}\par
{
{\f2 #include <Enemy.h>}}\par
Inheritance diagram for Enemy:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_enemy.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Enemy} (sf::Texture *texture, unsigned int id, sf::Vector3f spawnZ, int randOffset=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create new enemy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float gameSpeed) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this enemy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kill} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extra code for when enemy is killed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTranslate2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSizeIndex} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this enemy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDead} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Character} (sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new character who will have sprite from spritesheet. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Character} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the {\b Character} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > & {\b getBullets} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the currently fired bullets from this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSizeIndex} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b killBullet} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of bullet by index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position for the character itself. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b spawnWave} (std::vector< {\b Enemy} * > &, sf::Texture *, int, unsigned int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enemies come in waves, this will spawn the specified enemy wave by int id. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Member Functions inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _getSizeIndex} (unsigned int &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the height sector that character is in. Underscore infront indicates that it is not public. 0-3 3 indicates smallest, 0 indicates biggest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getVelocity} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the velocity of character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVelocity} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change the velocity of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBullet} (sf::IntRect)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change how the bullets from this character look. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateBullets} (sf::RenderWindow &window, float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b CharacterBullet::update()} on each bullet & deletes bullets that are not in the window. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMax} = 140\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMin} = 69\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMin} = -160\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMax} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b velocity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > {\b bullets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sizeIndex}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enemy} in the game. These use a recolored player bullet. \par
}{
Definition at line {\b 9} of file {\b Enemy.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Enemy\:Enemy}
{\xe \v Enemy\:Enemy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Enemy::Enemy (sf::Texture *  {\i texture}, unsigned int  {\i id}, sf::Vector3f  {\i spawnPos}, int  {\i randOffset} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create new enemy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i texture} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spawnZ} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 10} of file {\b Enemy.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getSizeIndex\:Enemy}
{\xe \v Enemy\:getSizeIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Enemy::getSizeIndex ()}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this enemy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 97} of file {\b Enemy.cpp}.}\par
}
{\xe \v getTranslate2\:Enemy}
{\xe \v Enemy\:getTranslate2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Enemy::getTranslate2 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b Enemy.h}.}\par
}
{\xe \v isDead\:Enemy}
{\xe \v Enemy\:isDead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Enemy::isDead (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b Enemy.h}.}\par
}
{\xe \v kill\:Enemy}
{\xe \v Enemy\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Enemy::kill (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extra code for when enemy is killed. }}\par
{
Implements {\b Character} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 106} of file {\b Enemy.cpp}.}\par
}
{\xe \v spawnWave\:Enemy}
{\xe \v Enemy\:spawnWave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Enemy::spawnWave (std::vector< {\b Enemy} * > &  {\i enemies}, sf::Texture *  {\i spritesheet}, int  {\i playerZ}, unsigned int  {\i wave}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enemies come in waves, this will spawn the specified enemy wave by int id. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enemies} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritesheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i playerZ} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i wave} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 119} of file {\b Enemy.cpp}.}\par
}
{\xe \v update\:Enemy}
{\xe \v Enemy\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Enemy::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this enemy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Reimplemented from {\b Character} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 58} of file {\b Enemy.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/Enemy/{\b Enemy.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/Enemy/{\b Enemy.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Entity Class Reference\par \pard\plain 
{\tc\tcl2 \v Entity}
{\xe \v Entity}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class for all entities in the game. }}\par
{
{\f2 #include <Entity.h>}}\par
Inheritance diagram for Entity:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_entity.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b update} (sf::RenderWindow &, float)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class for all entities in the game. \par
}{
Definition at line {\b 10} of file {\b Entity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Entity\:Entity}
{\xe \v Entity\:Entity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Entity::Entity ()}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }}\par
{
Definition at line {\b 7} of file {\b Entity.cpp}.}\par
}
{\xe \v ~Entity\:Entity}
{\xe \v Entity\:~Entity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Entity::~Entity (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }}\par
{
Definition at line {\b 21} of file {\b Entity.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getAnimationState\:Entity}
{\xe \v Entity\:getAnimationState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Entity::getAnimationState (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b Entity.h}.}\par
}
{\xe \v getBounds\:Entity}
{\xe \v Entity\:getBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect Entity::getBounds (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b Entity.h}.}\par
}
{\xe \v getPos\:Entity}
{\xe \v Entity\:getPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector3f Entity::getPos (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b Entity.h}.}\par
}
{\xe \v getSpritePos\:Entity}
{\xe \v Entity\:getSpritePos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f Entity::getSpritePos ()}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 40} of file {\b Entity.cpp}.}\par
}
{\xe \v kill\:Entity}
{\xe \v Entity\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Entity::kill ({\b Animation::Anim}  {\i animation} = {\f2 {\b Animation::CHARACTER_DEATH}}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }}\par
{
Reimplemented in {\b Obstacle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 30} of file {\b Entity.cpp}.}\par
}
{\xe \v setPos\:Entity}
{\xe \v Entity\:setPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Entity::setPos (sf::Vector3f  {\i pos}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b Entity.h}.}\par
}
{\xe \v update\:Entity}
{\xe \v Entity\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Entity::update (sf::RenderWindow & , float ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b Boss} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Enemy} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b BossBullet} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ObstacleBullet} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Character} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Obstacle} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b ZapWall} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CharacterBullet} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v animations\:Entity}
{\xe \v Entity\:animations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Animation} Entity::animations{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Entity.h}.}\par
}
{\xe \v dead\:Entity}
{\xe \v Entity\:dead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Entity::dead = false{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Entity.h}.}\par
}
{\xe \v debugFont\:Entity}
{\xe \v Entity\:debugFont}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Font Entity::debugFont{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Entity.h}.}\par
}
{\xe \v debugText\:Entity}
{\xe \v Entity\:debugText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Text Entity::debugText{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Entity.h}.}\par
}
{\xe \v sprite\:Entity}
{\xe \v Entity\:sprite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Sprite* Entity::sprite{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Entity.h}.}\par
}
{\xe \v spriteSheet\:Entity}
{\xe \v Entity\:spriteSheet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Texture* Entity::spriteSheet{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Entity.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/{\b Entity.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/{\b Entity.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game Class Reference\par \pard\plain 
{\tc\tcl2 \v Game}
{\xe \v Game}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main game and all related classes eventually end up being used here. {\b Game} loop is in here and is the 'heart' of the whole program. }}\par
{
{\f2 #include <Game.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize everything needed for the main game functionality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Game} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory when user is done playing the game. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the game, main game loop is also managed in here. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main game and all related classes eventually end up being used here. {\b Game} loop is in here and is the 'heart' of the whole program. \par
}{
Definition at line {\b 24} of file {\b Game.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Game\:Game}
{\xe \v Game\:Game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Game::Game ()}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize everything needed for the main game functionality. }}\par
{
Definition at line {\b 10} of file {\b Game.cpp}.}\par
}
{\xe \v ~Game\:Game}
{\xe \v Game\:~Game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Game::~Game ()}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory when user is done playing the game. }}\par
{
Definition at line {\b 88} of file {\b Game.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v run\:Game}
{\xe \v Game\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::run ()}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start the game, main game loop is also managed in here. }}\par
{
Definition at line {\b 116} of file {\b Game.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Game/{\b Game.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Game/{\b Game.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI Class Reference\par \pard\plain 
{\tc\tcl2 \v GUI}
{\xe \v GUI}
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all {\b GUI} used in the game, including all text. These are simple but can take a lot of space due to how much there is. Different GUIs are split into different render functions. }}\par
{
{\f2 #include <GUI.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GUI} (sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b GUI} (graphical user interface) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b render} (sf::RenderWindow &, float, int, int, {\b byte}, {\b byte})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw all the {\b GUI} to the screen each frame. Also run logic for certain interactive {\b GUI} elements and update them as needed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startRender} (sf::RenderWindow &, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rendering specifically for the start screen. This will include the leaderboard will the top 6 scores and names. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b renderScores} (sf::RenderWindow &, int[], std::string[])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepare the leaderboard scores to be rendered. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b renderEnd} (sf::RenderWindow &, {\b byte}=255, {\b byte}=0, const char[3]="   ")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specific {\b GUI} that renders once you've run out of lives. This includes the game over text and name entry screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b renderWin} (sf::RenderWindow &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Render the win screen each lap completed. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all {\b GUI} used in the game, including all text. These are simple but can take a lot of space due to how much there is. Different GUIs are split into different render functions. \par
}{
Definition at line {\b 14} of file {\b GUI.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GUI\:GUI}
{\xe \v GUI\:GUI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GUI::GUI (sf::Texture *  {\i spritesheet})}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b GUI} (graphical user interface) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritesheet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 8} of file {\b GUI.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v render\:GUI}
{\xe \v GUI\:render}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GUI::render (sf::RenderWindow &  {\i window}, float  {\i playerY}, int  {\i score}, int  {\i highScore}, {\b byte}  {\i fuel}, {\b byte}  {\i lives})}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw all the {\b GUI} to the screen each frame. Also run logic for certain interactive {\b GUI} elements and update them as needed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i playerY} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i score} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fuel} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 315} of file {\b GUI.cpp}.}\par
}
{\xe \v renderEnd\:GUI}
{\xe \v GUI\:renderEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GUI::renderEnd (sf::RenderWindow &  {\i window}, {\b byte}  {\i timeLeft} = {\f2 255}, {\b byte}  {\i selector} = {\f2 0}, const char  {\i name}[3] = {\f2 "\~ \~ \~ "})}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specific {\b GUI} that renders once you've run out of lives. This includes the game over text and name entry screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i state} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 547} of file {\b GUI.cpp}.}\par
}
{\xe \v renderScores\:GUI}
{\xe \v GUI\:renderScores}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GUI::renderScores (sf::RenderWindow &  {\i window}, int  {\i scores}[], std::string  {\i names}[])}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prepare the leaderboard scores to be rendered. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scores} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 486} of file {\b GUI.cpp}.}\par
}
{\xe \v renderWin\:GUI}
{\xe \v GUI\:renderWin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GUI::renderWin (sf::RenderWindow &  {\i window})}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Render the win screen each lap completed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 597} of file {\b GUI.cpp}.}\par
}
{\xe \v startRender\:GUI}
{\xe \v GUI\:startRender}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GUI::startRender (sf::RenderWindow &  {\i window}, int  {\i highScore})}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rendering specifically for the start screen. This will include the leaderboard will the top 6 scores and names. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i highScore} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 456} of file {\b GUI.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/{\b GUI.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/{\b GUI.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HMSection Class Reference\par \pard\plain 
{\tc\tcl2 \v HMSection}
{\xe \v HMSection}
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The height meter and related methods. }}\par
{
{\f2 #include <HMSection.h>}}\par
Inheritance diagram for HMSection:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_h_m_section.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Type} \{ {\b LINE}
, {\b OPEN}
, {\b TOP}
, {\b BOTTOM}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b progress} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make current section change by a stage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSection} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the texture by what current section should be. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setType} ({\b Type})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set what type the current section sprite should be. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fill} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current section should be full. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b empty} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current section should be empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getSection} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current section id. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The height meter and related methods. \par
}{
Definition at line {\b 8} of file {\b HMSection.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Type\:HMSection}
{\xe \v HMSection\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b HMSection::Type}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LINE\:HMSection}
{\xe \v HMSection\:LINE}
{\qr LINE{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
{\xe \v OPEN\:HMSection}
{\xe \v HMSection\:OPEN}
{\qr OPEN{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{\cell }{\row }
{\xe \v TOP\:HMSection}
{\xe \v HMSection\:TOP}
{\qr TOP{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\cell }{\cell }{\row }
{\xe \v BOTTOM\:HMSection}
{\xe \v HMSection\:BOTTOM}
{\qr BOTTOM{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 11} of file {\b HMSection.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v empty\:HMSection}
{\xe \v HMSection\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HMSection::empty ()}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current section should be empty. }}\par
{
Definition at line {\b 128} of file {\b HMSection.cpp}.}\par
}
{\xe \v fill\:HMSection}
{\xe \v HMSection\:fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HMSection::fill ()}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Current section should be full. }}\par
{
Definition at line {\b 106} of file {\b HMSection.cpp}.}\par
}
{\xe \v getSection\:HMSection}
{\xe \v HMSection\:getSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int HMSection::getSection ()}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current section id. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 50} of file {\b HMSection.cpp}.}\par
}
{\xe \v progress\:HMSection}
{\xe \v HMSection\:progress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HMSection::progress (int  {\i stage})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make current section change by a stage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stage} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 60} of file {\b HMSection.cpp}.}\par
}
{\xe \v setSection\:HMSection}
{\xe \v HMSection\:setSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HMSection::setSection (int  {\i sect})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the texture by what current section should be. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sect} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 8} of file {\b HMSection.cpp}.}\par
}
{\xe \v setType\:HMSection}
{\xe \v HMSection\:setType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HMSection::setType ({\b Type}  {\i type})}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set what type the current section sprite should be. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 25} of file {\b HMSection.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/HMSection/{\b HMSection.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/HMSection/{\b HMSection.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Obstacle Class Reference\par \pard\plain 
{\tc\tcl2 \v Obstacle}
{\xe \v Obstacle}
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Still obstacles that spawn across the levels. }}\par
{
{\f2 #include <Obstacle.h>}}\par
Inheritance diagram for Obstacle:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_obstacle.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ObstacleType} \{ {\b GAS_CAN} = 1
, {\b SATELLITE}
, {\b GREY_CANNON}
, {\b GREEN_CANNON}
, {\b MISSILE_UP}
, {\b PLANE}
, {\b SPACE_FUEL}
, {\b GREEN_CANNON_RIGHT}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Obstacle} (sf::Vector3f, sf::Texture *, int, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a turret obstacle with shooting and direction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Obstacle} (sf::Vector3f, sf::Texture *, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a non-turret obstacle (Still obstacle). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Obstacle} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the obstacle class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< sf::Vector3f > {\b getBulletLocations} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get positions for all bullets of the obstacle (For turrets). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, int playerZ, float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this obstacle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default {\b Entity::update} override. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPresent} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if this obstacle exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTurret} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if obstacle is a turret. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bulletKill} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of obstacles bullet by index (For turrets). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObstacleType} {\b getType} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get what type of obstacle this is. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getScore} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the score to add when the obstacle is destroyed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH}) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Death animation. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Still obstacles that spawn across the levels. \par
}{
Definition at line {\b 14} of file {\b Obstacle.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ObstacleType\:Obstacle}
{\xe \v Obstacle\:ObstacleType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Obstacle::ObstacleType}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v GAS_CAN\:Obstacle}
{\xe \v Obstacle\:GAS_CAN}
{\qr GAS_CAN{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
\cell }{\cell }{\row }
{\xe \v SATELLITE\:Obstacle}
{\xe \v Obstacle\:SATELLITE}
{\qr SATELLITE{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\cell }{\cell }{\row }
{\xe \v GREY_CANNON\:Obstacle}
{\xe \v Obstacle\:GREY_CANNON}
{\qr GREY_CANNON{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\cell }{\cell }{\row }
{\xe \v GREEN_CANNON\:Obstacle}
{\xe \v Obstacle\:GREEN_CANNON}
{\qr GREEN_CANNON{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\cell }{\cell }{\row }
{\xe \v MISSILE_UP\:Obstacle}
{\xe \v Obstacle\:MISSILE_UP}
{\qr MISSILE_UP{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\cell }{\cell }{\row }
{\xe \v PLANE\:Obstacle}
{\xe \v Obstacle\:PLANE}
{\qr PLANE{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\cell }{\cell }{\row }
{\xe \v SPACE_FUEL\:Obstacle}
{\xe \v Obstacle\:SPACE_FUEL}
{\qr SPACE_FUEL{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
\cell }{\cell }{\row }
{\xe \v GREEN_CANNON_RIGHT\:Obstacle}
{\xe \v Obstacle\:GREEN_CANNON_RIGHT}
{\qr GREEN_CANNON_RIGHT{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 29} of file {\b Obstacle.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Obstacle\:Obstacle}
{\xe \v Obstacle\:Obstacle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Obstacle::Obstacle (sf::Vector3f  {\i pos}, sf::Texture *  {\i tex}, int  {\i delay}, int  {\i dir})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a turret obstacle with shooting and direction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tex} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delay} \cell }{(type 5 only)Delay in frames before a rocket begins shooting.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dir} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Obstacle.cpp}.}\par
}
{\xe \v Obstacle\:Obstacle}
{\xe \v Obstacle\:Obstacle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Obstacle::Obstacle (sf::Vector3f  {\i pos}, sf::Texture *  {\i tex}, int  {\i type})}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a non-turret obstacle (Still obstacle). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tex} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 91} of file {\b Obstacle.cpp}.}\par
}
{\xe \v ~Obstacle\:Obstacle}
{\xe \v Obstacle\:~Obstacle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Obstacle::~Obstacle (){\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the obstacle class. }}\par
{
Definition at line {\b 136} of file {\b Obstacle.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v bulletKill\:Obstacle}
{\xe \v Obstacle\:bulletKill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Obstacle::bulletKill (int  {\i bullet})}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of obstacles bullet by index (For turrets). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bullet} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 337} of file {\b Obstacle.cpp}.}\par
}
{\xe \v getBulletLocations\:Obstacle}
{\xe \v Obstacle\:getBulletLocations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< sf::Vector3f > Obstacle::getBulletLocations ()}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get positions for all bullets of the obstacle (For turrets). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector of vectors of 3 floats\par
}}}{
Definition at line {\b 160} of file {\b Obstacle.cpp}.}\par
}
{\xe \v getScore\:Obstacle}
{\xe \v Obstacle\:getScore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Obstacle::getScore ()}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the score to add when the obstacle is destroyed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
score\par
}}}{
Definition at line {\b 359} of file {\b Obstacle.cpp}.}\par
}
{\xe \v getType\:Obstacle}
{\xe \v Obstacle\:getType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Obstacle::ObstacleType} Obstacle::getType ()}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get what type of obstacle this is. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An int\par
}}}{
Definition at line {\b 349} of file {\b Obstacle.cpp}.}\par
}
{\xe \v isPresent\:Obstacle}
{\xe \v Obstacle\:isPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Obstacle::isPresent ()}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if this obstacle exists. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 315} of file {\b Obstacle.cpp}.}\par
}
{\xe \v isTurret\:Obstacle}
{\xe \v Obstacle\:isTurret}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Obstacle::isTurret ()}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if obstacle is a turret. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Boolean\par
}}}{
Definition at line {\b 326} of file {\b Obstacle.cpp}.}\par
}
{\xe \v kill\:Obstacle}
{\xe \v Obstacle\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Obstacle::kill ({\b Animation::Anim}  {\i animation} = {\f2 {\b Animation::CHARACTER_DEATH}}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Death animation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i animation} \cell }{\cell }
{\row }
}
}{
Reimplemented from {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 147} of file {\b Obstacle.cpp}.}\par
}
{\xe \v update\:Obstacle}
{\xe \v Obstacle\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Obstacle::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default {\b Entity::update} override. }}\par
{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 305} of file {\b Obstacle.cpp}.}\par
}
{\xe \v update\:Obstacle}
{\xe \v Obstacle\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Obstacle::update (sf::RenderWindow &  {\i window}, int  {\i playerZ}, float  {\i gameSpeed})}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run the logic for this obstacle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 170} of file {\b Obstacle.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Obstacle/{\b Obstacle.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Obstacle/{\b Obstacle.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ObstacleBullet Class Reference\par \pard\plain 
{\tc\tcl2 \v ObstacleBullet}
{\xe \v ObstacleBullet}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\par
{
{\f2 #include <ObstacleBullet.h>}}\par
Inheritance diagram for ObstacleBullet:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_obstacle_bullet.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObstacleBullet} (sf::Vector3f, sf::Texture *, {\b BulletType})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for {\b ObstacleBullet}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the {\b ObstacleBullet}. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AbstractBullet} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the bullet is dead or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translate} (float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move a certain amount on the Z axis. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Types inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BulletType} \{ {\b Player}
, {\b Enemy}
, {\b Missile}
, {\b zBullet}
, {\b xBulletL}
, {\b xBulletR}
 \}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b AbstractBullet}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b alive} = true\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 6} of file {\b ObstacleBullet.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ObstacleBullet\:ObstacleBullet}
{\xe \v ObstacleBullet\:ObstacleBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ObstacleBullet::ObstacleBullet (sf::Vector3f  {\i pos}, sf::Texture *  {\i spriteSheet}, {\b BulletType}  {\i type})}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for {\b ObstacleBullet}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spriteSheet} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 9} of file {\b ObstacleBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v update\:ObstacleBullet}
{\xe \v ObstacleBullet\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObstacleBullet::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the {\b ObstacleBullet}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gameSpeed} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 46} of file {\b ObstacleBullet.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/{\b ObstacleBullet.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/{\b ObstacleBullet.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player Class Reference\par \pard\plain 
{\tc\tcl2 \v Player}
{\xe \v Player}
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The player character, also contains plane controls. }}\par
{
{\f2 #include <Player.h>}}\par
Inheritance diagram for Player:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_player.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Player} (sf::Texture *, unsigned int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create player character at position and load resources for them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, int, float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run all the logic and controls for player. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kill} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modify variables for when player dies or respawns. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetPos} (int zOffset=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the players position to default. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawHitmarker} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isAlive} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if player is alive. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isMissileable} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the horizontal missile should shoot at the player or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b restartMissileTimer} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Character} (sf::Texture *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new character who will have sprite from spritesheet. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Character} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to the {\b Character} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move the character by velocity and redraw them to the screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > & {\b getBullets} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the currently fired bullets from this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSizeIndex} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get public size index of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b killBullet} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get rid of bullet by index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position for the character itself. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Member Functions inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _getSizeIndex} (unsigned int &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the height sector that character is in. Underscore infront indicates that it is not public. 0-3 3 indicates smallest, 0 indicates biggest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getVelocity} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the velocity of character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVelocity} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change the velocity of this character. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBullet} (sf::IntRect)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change how the bullets from this character look. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateBullets} (sf::RenderWindow &window, float)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b CharacterBullet::update()} on each bullet & deletes bullets that are not in the window. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Character}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMax} = 140\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b yMin} = 69\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMin} = -160\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b xMax} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b velocity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b CharacterBullet} * > {\b bullets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sizeIndex}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The player character, also contains plane controls. \par
}{
Definition at line {\b 10} of file {\b Player.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Player\:Player}
{\xe \v Player\:Player}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Player::Player (sf::Texture *  {\i texture}, unsigned int  {\i startPos})}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create player character at position and load resources for them. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i texture} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPos} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 10} of file {\b Player.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v drawHitmarker\:Player}
{\xe \v Player\:drawHitmarker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::drawHitmarker (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b Player.h}.}\par
}
{\xe \v isAlive\:Player}
{\xe \v Player\:isAlive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Player::isAlive ()}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if player is alive. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 186} of file {\b Player.cpp}.}\par
}
{\xe \v isMissileable\:Player}
{\xe \v Player\:isMissileable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Player::isMissileable ()}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether the horizontal missile should shoot at the player or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 176} of file {\b Player.cpp}.}\par
}
{\xe \v kill\:Player}
{\xe \v Player\:kill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::kill (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modify variables for when player dies or respawns. }}\par
{
Implements {\b Character} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 156} of file {\b Player.cpp}.}\par
}
{\xe \v resetPos\:Player}
{\xe \v Player\:resetPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::resetPos (int  {\i zOffset} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the players position to default. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zOffset} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 166} of file {\b Player.cpp}.}\par
}
{\xe \v restartMissileTimer\:Player}
{\xe \v Player\:restartMissileTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::restartMissileTimer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Player.h}.}\par
}
{\xe \v update\:Player}
{\xe \v Player\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::update (sf::RenderWindow &  {\i window}, int  {\i stage}, float  {\i gameSpeed})}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run all the logic and controls for player. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i inSpace} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gameSpeed} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 42} of file {\b Player.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/Player/{\b Player.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Entity/Character/Player/{\b Player.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wall Class Reference\par \pard\plain 
{\tc\tcl2 \v Wall}
{\xe \v Wall}
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for the normal walls (stone brick). }}\par
{
{\f2 #include <Wall.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Wall} (sf::Texture *, sf::Vector3f, int size, std::vector< int >)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a section of walls, each one can be a closed or open wall piece. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawWalls} (sf::RenderWindow &window)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw each section of the wall if it will be visible on the screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (sf::Vector3f, int piece=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position of specificed wall piece. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTexture} (int, int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set texture for if this wall piece should be closed or open. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkOnScreen} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if this wall will be on screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< sf::Vector3f > & {\b getWallPositions} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get 3d position of this wall. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for the normal walls (stone brick). \par
}{
Definition at line {\b 10} of file {\b Wall.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Wall\:Wall}
{\xe \v Wall\:Wall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Wall::Wall (sf::Texture *  {\i tex}, sf::Vector3f  {\i pos}, int  {\i size}, std::vector< int >  {\i walls})}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a section of walls, each one can be a closed or open wall piece. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tex} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i walls} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 11} of file {\b Wall.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v checkOnScreen\:Wall}
{\xe \v Wall\:checkOnScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Wall::checkOnScreen ()}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if this wall will be on screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 91} of file {\b Wall.cpp}.}\par
}
{\xe \v drawWalls\:Wall}
{\xe \v Wall\:drawWalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Wall::drawWalls (sf::RenderWindow &  {\i window})}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw each section of the wall if it will be visible on the screen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 41} of file {\b Wall.cpp}.}\par
}
{\xe \v getWallPositions\:Wall}
{\xe \v Wall\:getWallPositions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< sf::Vector3f > & Wall::getWallPositions ()}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get 3d position of this wall. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector of 3 float vectors\par
}}}{
Definition at line {\b 101} of file {\b Wall.cpp}.}\par
}
{\xe \v setPosition\:Wall}
{\xe \v Wall\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Wall::setPosition (sf::Vector3f  {\i pos}, int  {\i piece} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set position of specificed wall piece. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i piece} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 63} of file {\b Wall.cpp}.}\par
}
{\xe \v setTexture\:Wall}
{\xe \v Wall\:setTexture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Wall::setTexture (int  {\i piece}, int  {\i tex})}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set texture for if this wall piece should be closed or open. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i piece} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tex} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 75} of file {\b Wall.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Wall/{\b Wall.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/Wall/{\b Wall.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZapWall Class Reference\par \pard\plain 
{\tc\tcl2 \v ZapWall}
{\xe \v ZapWall}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for other walls (blue lightning). }}\par
{
{\f2 #include <ZapWall.h>}}\par
Inheritance diagram for ZapWall:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_zap_wall.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZapWall} (sf::Texture *, sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ZapWall} constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} (sf::RenderWindow &, float) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the {\b ZapWall}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStartPos} (sf::Vector3f pos)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets start pos for the {\b ZapWall}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOnScreen} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns wether the wall intersects with the view. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getStartPosition} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial position of the wall. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Entity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setup {\b Entity} class variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Entity} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory related to {\b Entity} class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b kill} ({\b Animation::Anim} {\b animation}={\b Animation::CHARACTER_DEATH})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run death animation code for the killed entity. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getAnimationState} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPos} (sf::Vector3f pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector3f {\b getPos} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBounds} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getSpritePos} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the position of the related sprite for this entity. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b Entity}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Texture * {\b spriteSheet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite * {\b sprite}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Animation} {\b animations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dead} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Text {\b debugText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Font {\b debugFont}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for other walls (blue lightning). \par
}{
Definition at line {\b 10} of file {\b ZapWall.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ZapWall\:ZapWall}
{\xe \v ZapWall\:ZapWall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ZapWall::ZapWall (sf::Texture *  {\i tex}, sf::Vector3f  {\i pos})}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ZapWall} constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tex} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 9} of file {\b ZapWall.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getStartPosition\:ZapWall}
{\xe \v ZapWall\:getStartPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector3f ZapWall::getStartPosition ()}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial position of the wall. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Start position\par
}}}{
Definition at line {\b 93} of file {\b ZapWall.cpp}.}\par
}
{\xe \v isOnScreen\:ZapWall}
{\xe \v ZapWall\:isOnScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ZapWall::isOnScreen ()}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns wether the wall intersects with the view. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the {\b ZapWall} is on screen\par
}}}{
Definition at line {\b 83} of file {\b ZapWall.cpp}.}\par
}
{\xe \v setStartPos\:ZapWall}
{\xe \v ZapWall\:setStartPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ZapWall::setStartPos (sf::Vector3f  {\i pos})}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets start pos for the {\b ZapWall}. }}\par
{
Definition at line {\b 73} of file {\b ZapWall.cpp}.}\par
}
{\xe \v update\:ZapWall}
{\xe \v ZapWall\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ZapWall::update (sf::RenderWindow &  {\i window}, float  {\i gameSpeed}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update the {\b ZapWall}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gameSpeed} \cell }{\cell }
{\row }
}
}{
Implements {\b Entity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 26} of file {\b ZapWall.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/ZapWall/{\b ZapWall.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/ZapWall/{\b ZapWall.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZaxxonText Class Reference\par \pard\plain 
{\tc\tcl2 \v ZaxxonText}
{\xe \v ZaxxonText}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to grab text sprites from spritesheet given char or string. }}\par
{
{\f2 #include <ZaxxonText.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static sf::Sprite {\b get} (sf::Texture *, char)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take character or hex value then convert it and return the matching character/symbol from our spritesheet. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b string} (sf::Texture *, std::string, sf::Sprite *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take a string of characters or hex values then convert all and then fill given sprite array with the matching characters/symbols for each. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to grab text sprites from spritesheet given char or string. \par
}{
Definition at line {\b 8} of file {\b ZaxxonText.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get\:ZaxxonText}
{\xe \v ZaxxonText\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Sprite ZaxxonText::get (sf::Texture *  {\i spritemap}, char  {\i in}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take character or hex value then convert it and return the matching character/symbol from our spritesheet. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritemap} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i in} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Sprite of character or symbol\par
}}}{
Definition at line {\b 11} of file {\b ZaxxonText.cpp}.}\par
}
{\xe \v string\:ZaxxonText}
{\xe \v ZaxxonText\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ZaxxonText::string (sf::Texture *  {\i spritemap}, std::string  {\i in}, sf::Sprite *  {\i arr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Take a string of characters or hex values then convert all and then fill given sprite array with the matching characters/symbols for each. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i spritemap} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i in} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arr} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 41} of file {\b ZaxxonText.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/ZaxxonText/{\b ZaxxonText.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Zaxxon/src/GUI/ZaxxonText/{\b ZaxxonText.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Animation/Animation.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Animation/Animation.cpp}
{\xe \v C:/Zaxxon/src/Animation/Animation.cpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Animation.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b animation} = void(Animation::*)(sf::Sprite*)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v animation\:Animation.cpp}
{\xe \v Animation.cpp\:animation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b animation} = void(Animation::*)(sf::Sprite*)}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b Animation.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Animation.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Animation/Animation.cpp}
{\xe \v C:/Zaxxon/src/Animation/Animation.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Animation.h"}\par
00002 {\cf17 using }animation = void(Animation::*)(sf::Sprite*);\par
00003 \par
00007 Animation::Animation()\par
00008 \{\par
00009     {\cf20 // Setup death explosion frames}\par
00010     frames[0] = sf::IntRect(184, 144, 31, 31);\par
00011     frames[1] = sf::IntRect(224, 144, 31, 31);\par
00012 \par
00013     {\cf20 // Alt death explosion frames}\par
00014     frames[7] = sf::IntRect(7, 147, 31, 27);\par
00015     frames[6] = sf::IntRect(49, 147, 30, 28);\par
00016     frames[5] = sf::IntRect(81, 147, 22, 27);\par
00017     frames[4] = sf::IntRect(109, 147, 20, 28);\par
00018     frames[3] = sf::IntRect(137, 147, 20, 31);\par
00019     frames[2] = sf::IntRect(158, 147, 17, 27);\par
00020 \par
00021     {\cf20 // Launch animation}\par
00022     frames[8] = sf::IntRect(119, 71, 38, 27);\par
00023     frames[9] = sf::IntRect(159, 72, 38, 27);\par
00024 \par
00025     {\cf20 // Wall bullet Death animation}\par
00026     frames[10] = sf::IntRect(264, 154, 279 - 264, 175 - 154);\par
00027     frames[11] = sf::IntRect(288, 146, 28, 30);\par
00028 \par
00029     {\cf20 // Normal bullet death animations}\par
00030     frames[12] = sf::IntRect(160, 161, 174 - 160, 175 - 161);\par
00031     frames[13] = sf::IntRect(136, 160, 151 - 136, 175 - 160);\par
00032     frames[14] = sf::IntRect(112, 158, 128 - 112, 175 - 158);\par
00033     frames[15] = sf::IntRect(80, 156, 99 - 80, 175 - 156);\par
00034     frames[16] = sf::IntRect(48, 151, 70 - 48, 175 - 151);\par
00035     frames[17] = sf::IntRect(8, 150, 34 - 8, 176 - 150);\par
00036 \par
00037     {\cf20 // Numbers for obstacles after death}\par
00038     frames[18] = sf::IntRect(184, 121, 211 - 184, 135 - 121); {\cf20 // 0}\par
00039     frames[19] = sf::IntRect(224, 113, 255 - 224, 136 - 113); {\cf20 // 200}\par
00040     frames[20] = sf::IntRect(264, 113, 295 - 264, 135 - 113); {\cf20 // 500}\par
00041     frames[21] = sf::IntRect(305, 113, 334 - 305, 135 - 113); {\cf20 // 1000}\par
00042 \par
00043     {\cf20 // rocket flicker}\par
00044     frames[22] = sf::IntRect(80, 70, 10, 25);\par
00045     frames[23] = sf::IntRect(102, 70, 10, 25);\par
00046 \par
00047     {\cf20 // red rocket flicker}\par
00048     frames[24] = sf::IntRect(302, 197, 10, 25);\par
00049     frames[25] = sf::IntRect(324, 197, 10, 25);\par
00050 \par
00051     kill = {\cf17 false};\par
00052 \}\par
00053 \par
00054 \par
00058 Animation::~Animation()\par
00059 \{\par
00060     {\cf19 for} (std::thread* thread : threads)\par
00061     \{\par
00062         thread->join();\par
00063         {\cf17 delete} thread;\par
00064     \}\par
00065 \}\par
00066 \par
00067 \par
00074 {\cf18 void} Animation::run(sf::Sprite* sprite, Anim anim, {\cf18 unsigned} {\cf18 int} sizeIndex)\par
00075 \{\par
00076     timer.restart();\par
00077     this->spriteSizeIndex = sizeIndex;\par
00078 \par
00079     {\cf20 // safety check}\par
00080     {\cf19 if} (sprite == {\cf17 nullptr})\par
00081         {\cf19 return};\par
00082 \par
00083     {\cf20 //get the original texture so that the RESET animation can do so.}\par
00084     revert = sprite->getTextureRect();\par
00085 \par
00086     animation animationPtr = {\cf17 nullptr};\par
00087     {\cf19 switch} (anim)\par
00088     \{\par
00089     {\cf19 case} CHARACTER_DEATH:\par
00090         animationPtr = &Animation::fCHARACTER_DEATH;\par
00091         {\cf19 break};\par
00092     {\cf19 case} ALT_DEATH:\par
00093         animationPtr = &Animation::fALT_DEATH;\par
00094         {\cf19 break};\par
00095     {\cf19 case} BULLET_DEATH:\par
00096         animationPtr = &Animation::fBULLET_DEATH;\par
00097         {\cf19 break};\par
00098     {\cf19 case} WALLBULLET_DEATH:\par
00099         animationPtr = &Animation::fWALLBULLET_DEATH;\par
00100         {\cf19 break};\par
00101     {\cf19 case} LAUNCH:\par
00102         animationPtr = &Animation::fLAUNCH;\par
00103         {\cf19 break};\par
00104     {\cf19 case} ROCKET_FLICKER:\par
00105         animationPtr = &Animation::fROCKET_FLICKER;\par
00106         {\cf19 break};\par
00107     {\cf19 case} RESET:\par
00108         kill = {\cf17 true};\par
00109         {\cf19 break};\par
00110     \}\par
00111 \par
00112     {\cf19 if} (animationPtr != {\cf17 nullptr})\par
00113         threads.push_back({\cf17 new} std::thread(animationPtr, {\cf17 this}, sprite));\par
00114 \}\par
00115 \par
00116 \par
00121 {\cf18 void} Animation::fCHARACTER_DEATH(sf::Sprite* sprite)\par
00122 \{\par
00123     state = 2;\par
00124 \par
00125     {\cf19 while} (timer.getElapsedTime().asSeconds() < 1 && sprite != {\cf17 nullptr})\par
00126     \{\par
00127         {\cf18 int} current =\par
00128             {\cf17 static_cast<}{\cf18 int}{\cf17 >}(timer.getElapsedTime().asSeconds() * 4) % 2;\par
00129         sprite->setTextureRect(frames[current]);\par
00130         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00131     \}\par
00132 \par
00133     {\cf18 int} current = 18;\par
00134 \par
00135     {\cf19 switch} (spriteSizeIndex)\par
00136     \{\par
00137     {\cf19 case} 1: {\cf20 // 200}\par
00138         current = 19;\par
00139         {\cf19 break};\par
00140     {\cf19 case} 2: {\cf20 // 500}\par
00141         current = 20;\par
00142         {\cf19 break};\par
00143     {\cf19 case} 3: {\cf20 // 1000}\par
00144         current = 21;\par
00145         {\cf19 break};\par
00146     \}\par
00147 \par
00148     state = 4; {\cf20 // wont interact}\par
00149 \par
00150     {\cf19 while} (timer.getElapsedTime().asSeconds() < 2 && sprite != {\cf17 nullptr})\par
00151     \{\par
00152         sprite->setTextureRect(frames[current]);\par
00153         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00154     \}\par
00155     sprite->setTextureRect(frames[18]);\par
00156 \}\par
00157 \par
00158 \par
00163 {\cf18 void} Animation::fALT_DEATH(sf::Sprite* sprite)\par
00164 \{\par
00165     state = 2;\par
00166 \par
00167     {\cf19 while} (timer.getElapsedTime().asMilliseconds() < 500 && sprite != {\cf17 nullptr})\par
00168     \{\par
00169         {\cf18 int} current = (timer.getElapsedTime().asMilliseconds()\par
00170             * 12 / 1000 % 6) + 2;\par
00171         sprite->setTextureRect(frames[current]);\par
00172         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00173     \}\par
00174 \par
00175     state = 1;\par
00176 \}\par
00177 \par
00178 \par
00183 {\cf18 void} Animation::fLAUNCH(sf::Sprite* sprite)\par
00184 \{\par
00185     state = 3;\par
00186     {\cf18 int} current = 8;\par
00187 \par
00188     {\cf19 while} (timer.getElapsedTime().asSeconds() < 1 && sprite != {\cf17 nullptr})\par
00189     \{\par
00190         {\cf19 if} (timer.getElapsedTime().asMilliseconds() > 500 && current == 8)\par
00191             current++;\par
00192 \par
00193         sprite->setTextureRect(frames[current]);\par
00194         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00195     \}\par
00196 \par
00197     state = 4;\par
00198 \}\par
00199 \par
00200 \par
00205 {\cf18 void} Animation::fBULLET_DEATH(sf::Sprite* sprite)\par
00206 \{\par
00207     {\cf18 int} current = 10;\par
00208     {\cf18 bool} lastWentUp = {\cf17 false};\par
00209     state = 2;\par
00210 \par
00211     {\cf19 switch} (spriteSizeIndex)\par
00212     \{\par
00213     {\cf19 case} 0:\par
00214         current = 16;\par
00215         {\cf19 break};\par
00216     {\cf19 case} 1:\par
00217     {\cf19 case} 2:\par
00218         current = 14;\par
00219         {\cf19 break};\par
00220     {\cf19 case} 3:\par
00221     {\cf19 default}:\par
00222         current = 12;\par
00223         {\cf19 break};\par
00224     \}\par
00225 \par
00226     {\cf19 while} (timer.getElapsedTime().asSeconds() < 2 && sprite != {\cf17 nullptr})\par
00227     \{\par
00228         {\cf19 if} (timer.getElapsedTime().asMilliseconds() > 500 && current == 8)\par
00229             current++;\par
00230 \par
00231         {\cf20 // change every 1/2 second}\par
00232         {\cf19 if} (timer.getElapsedTime().asMilliseconds() % 500 == 0)\par
00233         \{\par
00234             {\cf19 if} (lastWentUp)\par
00235                 current--;\par
00236             {\cf19 else}\par
00237                 current++;\par
00238 \par
00239             lastWentUp = !lastWentUp;\par
00240         \}\par
00241 \par
00242         {\cf19 if} (sprite == {\cf17 nullptr})\par
00243             {\cf19 return};\par
00244         sprite->setTextureRect(frames[current]);\par
00245         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00246     \}\par
00247 \par
00248     state = 1;\par
00249 \}\par
00250 \par
00251 \par
00256 {\cf18 void} Animation::fWALLBULLET_DEATH(sf::Sprite* sprite)\par
00257 \{\par
00258     {\cf18 int} current = 10;\par
00259     state = 2;\par
00260 \par
00261     {\cf19 while} (timer.getElapsedTime().asSeconds() < 0.7 && sprite != {\cf17 nullptr})\par
00262     \{\par
00263         {\cf19 if} (timer.getElapsedTime().asMilliseconds() > 350)\par
00264             current = 10;\par
00265         {\cf19 else}\par
00266             current = 11;\par
00267 \par
00268         {\cf19 if} (sprite == {\cf17 nullptr})\par
00269             {\cf19 return};\par
00270         sprite->setTextureRect(frames[current]);\par
00271         std::this_thread::sleep_for(std::chrono::milliseconds(10));\par
00272     \}\par
00273 \par
00274     state = 1;\par
00275 \}\par
00276 \par
00281 {\cf18 void} Animation::fROCKET_FLICKER(sf::Sprite* sprite)\par
00282 \{\par
00283     state = 6;\par
00284 \par
00285     {\cf19 if} (!kill && sprite != {\cf17 nullptr})\par
00286     \{\par
00287         {\cf19 if} (spriteSizeIndex == 0) {\cf20 // green}\par
00288             sprite->setTextureRect(frames[22]);\par
00289         {\cf19 else} {\cf20 // red}\par
00290             sprite->setTextureRect(frames[24]);\par
00291     \}\par
00292     {\cf19 else}\par
00293         {\cf19 return};\par
00294     std::this_thread::sleep_for(std::chrono::milliseconds(100));\par
00295     {\cf19 if} (!kill && sprite != {\cf17 nullptr})\par
00296     \{\par
00297         {\cf19 if} (spriteSizeIndex == 0) {\cf20 // green}\par
00298             sprite->setTextureRect(frames[23]);\par
00299         {\cf19 else} {\cf20 // red}\par
00300             sprite->setTextureRect(frames[25]);\par
00301     \}\par
00302     {\cf19 else}\par
00303         {\cf19 return};\par
00304     std::this_thread::sleep_for(std::chrono::milliseconds(100));\par
00305 \par
00306     {\cf19 if} (!kill)\par
00307         state = 7;\par
00308 \}\par
00309 \par
00310 \par
00315 {\cf18 int} Animation::getState(){\cf17  const}\par
00316 {\cf17 }\{\par
00317     {\cf19 return} state;\par
00318 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Animation/Animation.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Animation/Animation.h}
{\xe \v C:/Zaxxon/src/Animation/Animation.h}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <thread>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Animation}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle (almost) all in-game animations. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Animation.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Animation/Animation.h}
{\xe \v C:/Zaxxon/src/Animation/Animation.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 {\cf21 #include <thread>}\par
00004 {\cf21 #include <vector>}\par
00005 \par
00006 \par
00010 {\cf17 class }Animation\par
00011 \{\par
00012 {\cf17 public}:\par
00013     {\cf17 enum} Anim\par
00014     \{\par
00015         CHARACTER_DEATH,\par
00016         ALT_DEATH,\par
00017         LAUNCH,\par
00018         BULLET_DEATH,\par
00019         WALLBULLET_DEATH,\par
00020         ROCKET_FLICKER,\par
00021         RESET\par
00022     \};\par
00023 \par
00024     Animation();\par
00025     ~Animation();\par
00026 \par
00027     {\cf20 // size index as an extra var for some animations}\par
00028     {\cf18 void} run(sf::Sprite*, Anim, {\cf18 unsigned} {\cf18 int} sizeIndex = 0);\par
00029     {\cf18 int} getState() {\cf17 const};\par
00030 \par
00031 {\cf17 private}:\par
00032     {\cf18 void} fCHARACTER_DEATH(sf::Sprite* sprite);\par
00033     {\cf18 void} fALT_DEATH(sf::Sprite* sprite);\par
00034     {\cf18 void} fLAUNCH(sf::Sprite* sprite);\par
00035     {\cf18 void} fBULLET_DEATH(sf::Sprite* sprite);\par
00036     {\cf18 void} fWALLBULLET_DEATH(sf::Sprite* sprite);\par
00037     {\cf18 void} fROCKET_FLICKER(sf::Sprite* sprite);\par
00038 \par
00039     std::vector<std::thread*> threads;\par
00040     sf::Clock timer;\par
00041     sf::IntRect frames[26], revert;\par
00042     {\cf18 int} state = 0;\par
00043     {\cf18 unsigned} {\cf18 int} spriteSizeIndex = 0;\par
00044     {\cf18 bool} kill = {\cf17 false};\par
00045 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Background/Background.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Background/Background.cpp}
{\xe \v C:/Zaxxon/src/Background/Background.cpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Background.h"}\par
{\f2 #include "Util/Util.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Background.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Background/Background.cpp}
{\xe \v C:/Zaxxon/src/Background/Background.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Background.h"}\par
00002 {\cf21 #include "Util/Util.h"}\par
00003 \par
00004 \par
00018 Background::Background(Stage startStage, sf::View& mainView,\par
00019                        sf::Texture* spritesheet,\par
00020                        std::vector<Obstacle*>& obstacles,\par
00021                        std::vector<Enemy*>& enemies, Player& player,\par
00022                        {\cf18 int} startPos, std::vector<Wall*>& walls,\par
00023                        std::vector<ZapWall*>& zapWalls\par
00024 )\par
00025 \{\par
00026     {\cf20 //load background textures}\par
00027     {\cf19 if} (!initial.loadFromFile({\cf22 "res/BackgroundInitial.png"}))\par
00028         std::cout << {\cf22 "Background file could not load\\n"};\par
00029     {\cf19 if} (!space.loadFromFile({\cf22 "res/BackgroundSpace2.png"}))\par
00030         std::cout << {\cf22 "Background file could not load\\n"};\par
00031     {\cf19 if} (!boss.loadFromFile({\cf22 "res/BackgroundBoss.png"}))\par
00032         std::cout << {\cf22 "Background file could not load\\n"};\par
00033 \par
00034     back.setTexture(boss);\par
00035     back.setOrigin(\par
00036         sf::Vector2f(0, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(back.getTexture()->getSize().y)));\par
00037     back.setPosition(sf::Vector2f(0, 240));\par
00038     changeStage(startStage, mainView, spritesheet, obstacles, enemies, player,\par
00039                 startPos, walls, zapWalls);\par
00040 \par
00041     {\cf19 if} (!death.loadFromFile({\cf22 "res/BackgroundDeath.png"}))\par
00042         std::cout << {\cf22 "Death overlay file failed to load\\n"};\par
00043 \par
00044     deathOverlay.setTexture(death);\par
00045     deathOverlay.setColor(sf::Color(255, 255, 255, 100));\par
00046 \}\par
00047 \par
00048 \par
00049 Background::~Background()\par
00050 \{\par
00051 \}\par
00052 \par
00053 \par
00066 {\cf18 void} Background::update(sf::RenderWindow& window, sf::View& mainView,\par
00067                         {\cf18 float} gameSpeed, sf::Texture* spritesheet,\par
00068                         std::vector<Obstacle*>& obstacles,\par
00069                         std::vector<Enemy*>& enemies, Player& player,\par
00070                         std::vector<Wall*>& walls,\par
00071                         std::vector<ZapWall*>& zapWalls\par
00072 )\par
00073 \{\par
00074     {\cf20 //checks the transition between stages}\par
00075     {\cf19 if} (backgroundFinished(mainView))\par
00076     \{\par
00077         {\cf19 switch} (stage)\par
00078         \{\par
00079         {\cf19 case} INITIAL:\par
00080             stage = SPACE;\par
00081             back.setTexture(space);\par
00082             resetPos(mainView, player, 0);\par
00083             {\cf19 break};\par
00084         {\cf19 case} SPACE:\par
00085             stage = BOSS;\par
00086             back.setTexture(boss);\par
00087             resetPos(mainView, player, 0);\par
00088             {\cf19 break};\par
00089         {\cf19 case} BOSS:\par
00090             stage = BOSSFIGHT;\par
00091         \}\par
00092 \par
00093         generateObstacles(stage, obstacles, spritesheet, walls, zapWalls);\par
00094         generateWaves(stage, enemies, spritesheet,\par
00095                       {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player.getPos().z));\par
00096     \}\par
00097 \par
00098     {\cf19 if} (!backgroundFinished(mainView))\par
00099     \{\par
00100         {\cf18 float} modifier = 1;\par
00101         {\cf19 if} (stage == SPACE) {\cf20 // space moves 2/3 speed}\par
00102             modifier = 0.66f;\par
00103         mainView.move(\par
00104             translateTo2d(sf::Vector3f(0, 0, -1.3f * gameSpeed * modifier)));\par
00105     \}\par
00106 \par
00107     {\cf20 // spawn waves that have gone past the z set in queue}\par
00108     {\cf19 if} (!waveQueue.empty() && player.getPos().z < waveQueue.front().first)\par
00109     \{\par
00110         Enemy::spawnWave(enemies, spritesheet,\par
00111                          {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player.getPos().z),\par
00112                          waveQueue.front().second);\par
00113         waveQueue.pop();\par
00114     \}\par
00115 \par
00116     window.draw(back);\par
00117 \}\par
00118 \par
00119 \par
00124 {\cf18 void} Background::setPosition(sf::Vector2f pos)\par
00125 \{\par
00126     back.setPosition(pos);\par
00127 \}\par
00128 \par
00129 \par
00143 {\cf18 void} Background::changeStage(Stage stage, sf::View& mainView,\par
00144                              sf::Texture* spritesheet,\par
00145                              std::vector<Obstacle*>& obstacles,\par
00146                              std::vector<Enemy*>& enemies, Player& player,\par
00147                              {\cf18 int} startPos, std::vector<Wall*>& walls,\par
00148                              std::vector<ZapWall*>& zapWalls\par
00149 )\par
00150 \{\par
00151     this->stage = stage;\par
00152     {\cf19 if} (stage == INITIAL)\par
00153         back.setTexture(initial);\par
00154     {\cf19 else} {\cf19 if} (stage == SPACE)\par
00155         back.setTexture(space);\par
00156     {\cf19 else}\par
00157         back.setTexture(boss);\par
00158     resetPos(mainView, player, startPos);\par
00159 \par
00160     generateObstacles(stage, obstacles, spritesheet, walls, zapWalls);\par
00161     generateWaves(stage, enemies, spritesheet,\par
00162                   {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player.getPos().z));\par
00163 \}\par
00164 \par
00165 \par
00171 {\cf18 bool} Background::backgroundFinished(sf::View& view)\par
00172 \{\par
00173     {\cf18 float} wXPos = view.getCenter().x - (view.getSize().x / 2);\par
00174 \par
00175     {\cf19 if} (stage == BOSS)\par
00176         {\cf19 return} wXPos >= 2050;\par
00177     {\cf19 if} (stage == SPACE)\par
00178         {\cf19 return} wXPos >= 1150;\par
00179     {\cf19 return} wXPos >= 1830;\par
00180 \}\par
00181 \par
00182 \par
00188 {\cf18 bool} Background::isInSpace({\cf18 int} z)\par
00189 \{\par
00190     {\cf20 // Initial -2800: space}\par
00191     {\cf20 // Boss -123: No space}\par
00192     {\cf18 bool} inSpace = {\cf17 false};\par
00193     {\cf19 switch} (stage)\par
00194     \{\par
00195     {\cf19 case} INITIAL:\par
00196         {\cf19 if} (z > -123 || z < -2800)\par
00197             inSpace = {\cf17 true};\par
00198         {\cf19 break};\par
00199     {\cf19 case} SPACE:\par
00200         inSpace = {\cf17 true};\par
00201         {\cf19 break};\par
00202     {\cf19 case} BOSS:\par
00203         {\cf19 if} (z > -123)\par
00204             inSpace = {\cf17 true};\par
00205     \}\par
00206 \par
00207     {\cf19 return} inSpace;\par
00208 \}\par
00209 \par
00210 \par
00217 {\cf18 void} Background::resetPos(sf::View& mainView, Player& player, {\cf18 int} startPos)\par
00218 \{\par
00219     {\cf20 //Sets the origin to the bottom left corner as that is where it will start }\par
00220     {\cf20 //on the screen}\par
00221     mainView.setCenter(sf::Vector2f(112, 100));\par
00222     back.setOrigin(\par
00223         sf::Vector2f(0, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(back.getTexture()->getSize().y)));\par
00224 \par
00225     {\cf18 int} adder = stage == SPACE ? 350 : 0;\par
00226     sf::Vector2f moveVector = sf::Vector2f(.8f * (startPos + adder),\par
00227                                    -.4f * (startPos + adder));\par
00228     mainView.move(moveVector);\par
00229 \par
00230     {\cf19 switch} (stage)\par
00231     \{\par
00232     {\cf19 case} SPACE:\par
00233         back.setPosition(sf::Vector2f(0, 224));\par
00234         player.resetPos(startPos + 350);\par
00235         {\cf19 break};\par
00236     {\cf19 case} BOSS:\par
00237         back.setPosition(sf::Vector2f(0, 238));\par
00238         player.resetPos(startPos);\par
00239         {\cf19 break};\par
00240     {\cf19 default}:\par
00241         back.setPosition(sf::Vector2f(0, 224));\par
00242         player.resetPos(startPos);\par
00243     \}\par
00244 \}\par
00245 \par
00246 \par
00253 {\cf18 void} Background::generateObstacles(Stage stage,\par
00254                                    std::vector<Obstacle*>& obstacles,\par
00255                                    sf::Texture* spriteSheet,\par
00256                                    std::vector<Wall*>& walls,\par
00257                                    std::vector<ZapWall*>& zapWalls)\par
00258 \{\par
00259     {\cf20 /*Shooting Obstacles}\par
00260 {\cf20     KEY}\par
00261 {\cf20     0 = Grey Turrets}\par
00262 {\cf20     1 = Green Turrets}\par
00263 {\cf20     2 = Shooting Up Bullets}\par
00264 {\cf20     3 = Green Shooting Right}\par
00265 {\cf20 }\par
00266 {\cf20     Stationary Obstacles}\par
00267 {\cf20     KEY}\par
00268 {\cf20     1 = gas can}\par
00269 {\cf20     2 = satellite}\par
00270 {\cf20     3 = plane}\par
00271 {\cf20     4 = blue floating gas can}\par
00272 {\cf20     */}\par
00273 \par
00274     {\cf19 for} (Obstacle* obstacle : obstacles)\par
00275         {\cf17 delete} obstacle;\par
00276     obstacles.clear();\par
00277 \par
00278     {\cf19 for} (Wall* wall : walls)\par
00279         {\cf17 delete} wall;\par
00280     walls.clear();\par
00281 \par
00282     {\cf19 for} (ZapWall* zapWall : zapWalls)\par
00283         {\cf17 delete} zapWall;\par
00284     zapWalls.clear();\par
00285 \par
00286     {\cf19 switch} (stage)\par
00287     \{\par
00288     {\cf19 case} INITIAL:\par
00289         {\cf20 //Shooting}\par
00290         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -380.f),\par
00291                                          spriteSheet, 100, 1));\par
00292         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-15.f, 139.f, -435.f),\par
00293                                          spriteSheet, 100, 0));\par
00294         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -800.f),\par
00295                                          spriteSheet, 100, 1));\par
00296         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -947.f),\par
00297                                          spriteSheet, 100, 1));\par
00298         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-120.f, 139.f, -1120.f),\par
00299                                          spriteSheet, 100, 0));\par
00300         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -1145.f),\par
00301                                          spriteSheet, 100, 0));\par
00302         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-142.f, 139.f, -1410.f),\par
00303                                          spriteSheet, 100, 0));\par
00304         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-10.f, 139.f, -1680.f),\par
00305                                          spriteSheet, 100, 0));\par
00306         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-5.f, 139.f, -2080.f),\par
00307                                          spriteSheet, 100, 3));\par
00308         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-5.f, 139.f, -2260.f),\par
00309                                          spriteSheet, 100, 3));\par
00310         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -2335.f),\par
00311                                          spriteSheet, 100, 0));\par
00312 \par
00313     {\cf20 //Non-Shooting}\par
00314         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-170.f, 139.f, -340.f),\par
00315                                          spriteSheet, 2));\par
00316         obstacles.push_back(\par
00317             {\cf17 new} Obstacle(sf::Vector3f(-80.f, 139.f, -590.f), spriteSheet, 1));\par
00318         obstacles.push_back(\par
00319             {\cf17 new} Obstacle(sf::Vector3f(-12.f, 139.f, -630.f), spriteSheet, 1));\par
00320         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-160.f, 139.f, -665.f),\par
00321                                          spriteSheet, 1));\par
00322         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-170.f, 139.f, -910.f),\par
00323                                          spriteSheet, 1));\par
00324         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-12.f, 139.f, -1000.f),\par
00325                                          spriteSheet, 1));\par
00326         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -1100.f),\par
00327                                          spriteSheet, 1));\par
00328         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-25.f, 139.f, -1305.f),\par
00329                                          spriteSheet, 1));\par
00330         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-135.f, 139.f, -1685.f),\par
00331                                          spriteSheet, 3));\par
00332         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-40.f, 139.f, -1770.f),\par
00333                                          spriteSheet, 3));\par
00334         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-130.f, 139.f, -1800.f),\par
00335                                          spriteSheet, 1));\par
00336         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -1900.f),\par
00337                                          spriteSheet, 1));\par
00338         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -2045.f),\par
00339                                          spriteSheet, 2));\par
00340         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-95.f, 139.f, -2175.f),\par
00341                                          spriteSheet, 1));\par
00342         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-40.f, 139.f, -2320.f),\par
00343                                          spriteSheet, 3));\par
00344         obstacles.push_back(\par
00345             {\cf17 new} Obstacle(sf::Vector3f(-5.f, 139.f, -2435.f), spriteSheet, 3));\par
00346         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-45.f, 139.f, -2460.f),\par
00347                                          spriteSheet, 3));\par
00348         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-125.f, 139.f, -2490.f),\par
00349                                          spriteSheet, 1));\par
00350         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-100.f, 139.f, -2635.f),\par
00351                                          spriteSheet, 1));\par
00352         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-150.f, 139.f, -2635.f),\par
00353                                          spriteSheet, 2));\par
00354 \par
00355     {\cf20 //Shooting Up Missiles}\par
00356         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-79.f, 139.f, -335.f),\par
00357                                          spriteSheet, 130, 2));\par
00358         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-25.f, 139.f, -534.298f),\par
00359                                          spriteSheet, 300, 2));\par
00360         obstacles.push_back({\cf17 new} Obstacle(\par
00361             sf::Vector3f(-176.f, 139.6f, -550.697f), spriteSheet, 370, 2));\par
00362         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-15.f, 139.6f, -857.029f),\par
00363                                          spriteSheet, 650, 2));\par
00364         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-135.f, 139.f, -840.029f),\par
00365                                          spriteSheet, 650, 2));\par
00366         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-62.f, 139.f, -1048.13f),\par
00367                                          spriteSheet, 850, 2));\par
00368         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-141.f, 139.f, -1218.6f),\par
00369                                          spriteSheet, 950, 2));\par
00370         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-10.f, 139.f, -1258.41f),\par
00371                                          spriteSheet, 1050, 2));\par
00372         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-30.f, 139.f, -1515.31f),\par
00373                                          spriteSheet, 1350, 4));\par
00374         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-185.f, 139.f, -1460.61f),\par
00375                                          spriteSheet, 1350, 4));\par
00376         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-145.f, 139.f, -1644.61f),\par
00377                                          spriteSheet, 1450, 4));\par
00378         obstacles.push_back({\cf17 new} Obstacle(\par
00379             sf::Vector3f(-100.f, 139.333f, -1764.57f), spriteSheet, 1700, 4));\par
00380         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-98.4f, 139.f, -2115.49f),\par
00381                                          spriteSheet, 1850, 4));\par
00382         obstacles.push_back({\cf17 new} Obstacle(\par
00383             sf::Vector3f(-20.2f, 139.333f, -2148.29f), spriteSheet, 1850, 4));\par
00384         obstacles.push_back({\cf17 new} Obstacle(\par
00385             sf::Vector3f(-151.2f, 139.f, -2268.38f), spriteSheet, 2100, 4));\par
00386         obstacles.push_back({\cf17 new} Obstacle(\par
00387             sf::Vector3f(-65.2f, 139.667f, -2257.88f), spriteSheet, 2100, 4));\par
00388         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-42.6f, 139.f, -2617.49f),\par
00389                                          spriteSheet, 2300, 4));\par
00390 \par
00391     {\cf20 /* Walls}\par
00392 {\cf20     KEY for Vector}\par
00393 {\cf20     0 = closed wall}\par
00394 {\cf20     1 = open wall}\par
00395 {\cf20     */}\par
00396         walls.push_back({\cf17 new} Wall(spriteSheet, sf::Vector3f(0.f, 70.f, -122.f),\par
00397                                  2, std::vector<int>\{0, 1\}));\par
00398         walls.at(0)->setPosition(sf::Vector3f(-160.f, 70.f, -122.f), 1);\par
00399         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00400                                  sf::Vector3f(-63.f, 130.f, -755.f), 3,\par
00401                                  std::vector<int>\{1, 1, 1\}));\par
00402         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00403                                  sf::Vector3f(23.f, 130.f, -1423.f), 3,\par
00404                                  std::vector<int>\{1, 1, 0\}));\par
00405         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00406                                  sf::Vector3f(-26.f, 130.f, -2782.f), 2,\par
00407                                  std::vector<int>\{1, 1\}));\par
00408 \par
00409     {\cf20 //Zap Walls}\par
00410         zapWalls.push_back(\par
00411             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-10, 125, -1940)));\par
00412         {\cf19 break};\par
00413 \par
00414     {\cf19 case} SPACE:\par
00415         {\cf20 //Blue Space Gas Cans}\par
00416         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-120.f, 139.f, -960.f),\par
00417                                          spriteSheet, 4));\par
00418         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-100.f, 139.f, -2500.f),\par
00419                                          spriteSheet, 4));\par
00420         {\cf19 break};\par
00421 \par
00422     {\cf19 case} BOSS:\par
00423         {\cf20 //Area are made by the sections of map between walls}\par
00424 \par
00425         walls.push_back({\cf17 new} Wall(spriteSheet, sf::Vector3f(-9.f, 70.f, -106.f),\par
00426                                  3, std::vector<int>\{0, 1, 1\}));\par
00427         walls.at(0)->setPosition(sf::Vector3f(-130.f, 70.f, -106.f), 1);\par
00428         walls.at(0)->setPosition(sf::Vector3f(-168.f, 70.f, -106.f), 2);\par
00429 \par
00430     {\cf20 //First Area}\par
00431         obstacles.push_back(\par
00432             {\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -320.f), spriteSheet, 1));\par
00433         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -370.f),\par
00434                                          spriteSheet, 100, 1));\par
00435         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-120.f, 139.f, -460.f),\par
00436                                          spriteSheet, 1));\par
00437         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-30.f, 139.f, -460.f),\par
00438                                          spriteSheet, 100, 0));\par
00439         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -460.f),\par
00440                                          spriteSheet, 2));\par
00441 \par
00442         walls.push_back({\cf17 new} Wall(spriteSheet, sf::Vector3f(7.f, 112.f, -550.f),\par
00443                                  2, std::vector<int>\{0, 1\}));\par
00444         walls.at(1)->setPosition(sf::Vector3f(-153.f, 112.f, -550.f), 1);\par
00445 \par
00446         zapWalls.push_back(\par
00447             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-10, 90, -550)));\par
00448         zapWalls.push_back(\par
00449             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-10, 70, -550)));\par
00450 \par
00451     {\cf20 //Second Area}\par
00452         obstacles.push_back(\par
00453             {\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -800.f), spriteSheet, 1));\par
00454         obstacles.push_back(\par
00455             {\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -865.f), spriteSheet, 1));\par
00456         obstacles.push_back(\par
00457             {\cf17 new} Obstacle(sf::Vector3f(-90.f, 139.f, -920.f), spriteSheet, 1));\par
00458         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-30.f, 139.f, -910.f),\par
00459                                          spriteSheet, 100, 0));\par
00460         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-140.f, 139.f, -910.f),\par
00461                                          spriteSheet, 100, 0));\par
00462 \par
00463         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00464                                  sf::Vector3f(-136.f, 82.f, -978.f), 2,\par
00465                                  std::vector<int>\{0, 1\}));\par
00466 \par
00467         zapWalls.push_back(\par
00468             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-30, 60, -978)));\par
00469 \par
00470     {\cf20 //Third Area}\par
00471         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -1200.f),\par
00472                                          spriteSheet, 1));\par
00473         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-100.f, 139.f, -1210.f),\par
00474                                          spriteSheet, 1));\par
00475         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-140.f, 139.f, -1230.f),\par
00476                                          spriteSheet, 1));\par
00477         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-185.f, 139.f, -1275.f),\par
00478                                          spriteSheet, 100, 1));\par
00479 \par
00480         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00481                                  sf::Vector3f(27.f, 139.f, -1408.f), 3,\par
00482                                  std::vector<int>\{1, 0, 1\}));\par
00483         walls.at(3)->setPosition(sf::Vector3f(-133.f, 139.f, -1407.f), 2);\par
00484 \par
00485         zapWalls.push_back(\par
00486             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 120, -1407)));\par
00487         zapWalls.push_back(\par
00488             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 100, -1407)));\par
00489         zapWalls.\par
00490             push_back({\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 80, -1407)));\par
00491 \par
00492     {\cf20 //Fourth Area}\par
00493         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-40.f, 139.f, -1510.f),\par
00494                                          spriteSheet, 100, 3));\par
00495         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-200.f, 139.f, -1540.f),\par
00496                                          spriteSheet, 100, 1));\par
00497         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-30.f, 139.f, -1630.f),\par
00498                                          spriteSheet, 1));\par
00499         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-180.f, 139.f, -1670.f),\par
00500                                          spriteSheet, 2));\par
00501         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-80.f, 139.f, -1680.f),\par
00502                                          spriteSheet, 1));\par
00503         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-130.f, 139.f, -1750.f),\par
00504                                          spriteSheet, 100, 0));\par
00505 \par
00506         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00507                                  sf::Vector3f(10.f, 112.f, -1830.f), 3,\par
00508                                  std::vector<int>\{0, 1, 1\}));\par
00509         walls.at(4)->setPosition(sf::Vector3f(-112.f, 112.f, -1829.f), 1);\par
00510         walls.at(4)->setPosition(sf::Vector3f(-152.f, 112.f, -1829.f), 2);\par
00511 \par
00512         zapWalls.\par
00513             push_back({\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 90, -1829)));\par
00514         zapWalls.\par
00515             push_back({\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 70, -1829)));\par
00516 \par
00517     {\cf20 //Fifth Area}\par
00518         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-35.f, 139.f, -1990.f),\par
00519                                          spriteSheet, 1));\par
00520         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-110.f, 139.f, -2110.f),\par
00521                                          spriteSheet, 1));\par
00522         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -2180.f),\par
00523                                          spriteSheet, 100, 0));\par
00524         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-100.f, 139.f, -2180.f),\par
00525                                          spriteSheet, 1));\par
00526         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-160.f, 139.f, -2180.f),\par
00527                                          spriteSheet, 1));\par
00528 \par
00529         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00530                                  sf::Vector3f(-15.f, 82.f, -2260.f), 3,\par
00531                                  std::vector<int>\{0, 1, 1\}));\par
00532         walls.at(5)->setPosition(sf::Vector3f(-133.f, 82.f, -2259.f), 1);\par
00533         walls.at(5)->setPosition(sf::Vector3f(-173.f, 82.f, -2259.f), 2);\par
00534 \par
00535         zapWalls.push_back(\par
00536             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-20, 60, -2259)));\par
00537 \par
00538     {\cf20 //Sixth Area}\par
00539         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-40.f, 139.f, -2420.f),\par
00540                                          spriteSheet, 100, 3));\par
00541         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-105.f, 139.f, -2540.f),\par
00542                                          spriteSheet, 100, 0));\par
00543         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-45.f, 139.f, -2580.f),\par
00544                                          spriteSheet, 1));\par
00545         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-155.f, 139.f, -2580.f),\par
00546                                          spriteSheet, 2));\par
00547 \par
00548         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00549                                  sf::Vector3f(-56.f, 139.f, -2687.f), 3,\par
00550                                  std::vector<int>\{1, 1, 1\}));\par
00551 \par
00552         zapWalls.push_back(\par
00553             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 120, -2687)));\par
00554         zapWalls.push_back(\par
00555             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 100, -2687)));\par
00556         zapWalls.\par
00557             push_back({\cf17 new} ZapWall(spriteSheet, sf::Vector3f(0, 80, -2687)));\par
00558 \par
00559     {\cf20 //Seventh Area}\par
00560         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-55.f, 139.f, -2820.f),\par
00561                                          spriteSheet, 1));\par
00562         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-60.f, 139.f, -2875.f),\par
00563                                          spriteSheet, 1));\par
00564         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -2950.f),\par
00565                                          spriteSheet, 100, 3));\par
00566         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-50.f, 139.f, -3010.f),\par
00567                                          spriteSheet, 1));\par
00568 \par
00569         walls.push_back({\cf17 new} Wall(spriteSheet,\par
00570                                  sf::Vector3f(-40.f, 82.f, -3060.f), 3,\par
00571                                  std::vector<int>\{0, 1, 1\}));\par
00572         walls.at(7)->setPosition(sf::Vector3f(-161.f, 82.f, -3060.f), 1);\par
00573         walls.at(7)->setPosition(sf::Vector3f(-201.f, 82.f, -3060.f), 2);\par
00574 \par
00575         zapWalls.push_back(\par
00576             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-50, 60, -3060)));\par
00577         zapWalls.push_back(\par
00578             {\cf17 new} ZapWall(spriteSheet, sf::Vector3f(-50, 40, -3060)));\par
00579 \par
00580     {\cf20 //Eight Area}\par
00581         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-35.f, 139.f, -3240.f),\par
00582                                          spriteSheet, 1));\par
00583         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-80.f, 139.f, -3250.f),\par
00584                                          spriteSheet, 1));\par
00585         obstacles.push_back({\cf17 new} Obstacle(sf::Vector3f(-35.f, 139.f, -3330.f),\par
00586                                          spriteSheet, 1));\par
00587         {\cf20 //Adjusting Positions}\par
00588         {\cf19 for} (Obstacle* obstacle : obstacles)\par
00589             obstacle->setPos(obstacle->getPos() + sf::Vector3f(0, -6, 0));\par
00590         {\cf19 for} (ZapWall* zw : zapWalls)\par
00591             zw->setStartPos(zw->getStartPosition() + sf::Vector3f(0, -6, 0));\par
00592         {\cf19 for} (Wall* wall : walls)\par
00593             {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < wall->getWallPositions().size(); i++)\par
00594                 wall->setPosition(\par
00595                     wall->getWallPositions()[i] + sf::Vector3f(0, -6, 0), i);\par
00596         {\cf19 break};\par
00597     \}\par
00598 \}\par
00599 \par
00600 \par
00608 {\cf18 void} Background::generateWaves(Stage stage,\par
00609                                std::vector<Enemy*>& enemies,\par
00610                                sf::Texture* spriteSheet, {\cf18 int} playerZ)\par
00611 \{\par
00612     {\cf19 for} (Enemy* enemy : enemies)\par
00613         {\cf17 delete} enemy;\par
00614     enemies.clear();\par
00615     {\cf20 // equivalent to waveQueue.clear();}\par
00616     std::queue<std::pair<int, unsigned int>>().swap(waveQueue);\par
00617 \par
00618     {\cf20 // format waveQueue.push(std::pair<int, unsigned int>(spawnZ, waveId));}\par
00619     {\cf19 switch} (stage)\par
00620     \{\par
00621     {\cf19 case} SPACE: {\cf20 // further below Z should be lesser}\par
00622         waveQueue.push(std::pair<int, unsigned int>(-460, 0));\par
00623         waveQueue.push(std::pair<int, unsigned int>(-493, 0));\par
00624         waveQueue.push(std::pair<int, unsigned int>(-526, 0));\par
00625         waveQueue.push(std::pair<int, unsigned int>(-559, 0));\par
00626         waveQueue.push(std::pair<int, unsigned int>(-652, 1));\par
00627         waveQueue.push(std::pair<int, unsigned int>(-665, 2));\par
00628         waveQueue.push(std::pair<int, unsigned int>(-678, 3));\par
00629         waveQueue.push(std::pair<int, unsigned int>(-991, 4));\par
00630         waveQueue.push(std::pair<int, unsigned int>(-1051, 4));\par
00631         waveQueue.push(std::pair<int, unsigned int>(-1084, 4));\par
00632         waveQueue.push(std::pair<int, unsigned int>(-1104, 5));\par
00633         waveQueue.push(std::pair<int, unsigned int>(-1170, 6));\par
00634         waveQueue.push(std::pair<int, unsigned int>(-1203, 6));\par
00635         waveQueue.push(std::pair<int, unsigned int>(-1236, 6));\par
00636         waveQueue.push(std::pair<int, unsigned int>(-1269, 6));\par
00637         waveQueue.push(std::pair<int, unsigned int>(-1315, 7));\par
00638         waveQueue.push(std::pair<int, unsigned int>(-1350, 3));\par
00639         waveQueue.push(std::pair<int, unsigned int>(-1400, 2));\par
00640         waveQueue.push(std::pair<int, unsigned int>(-1440, 4));\par
00641         waveQueue.push(std::pair<int, unsigned int>(-1490, 4));\par
00642         {\cf19 break};\par
00643     \}\par
00644 \}\par
00645 \par
00646 \par
00651 Background::Stage Background::getStage()\par
00652 \{\par
00653     {\cf19 return} stage;\par
00654 \}\par
00655 \par
00656 \par
00663 {\cf18 void} Background::flashColor(sf::RenderWindow& window)\par
00664 \{\par
00665     window.draw(deathOverlay);\par
00666 \}\par
00667 \par
00668 \par
00673 {\cf18 void} Background::setStage(Stage newStage)\par
00674 \{\par
00675     stage = newStage;\par
00676 \par
00677     {\cf19 if} (stage == INITIAL)\par
00678         back.setTexture(initial);\par
00679     {\cf19 else} {\cf19 if} (stage == SPACE)\par
00680         back.setTexture(space);\par
00681     {\cf19 else} {\cf19 if} (stage == BOSS)\par
00682         back.setTexture(boss);\par
00683 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Background/Background.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Background/Background.h}
{\xe \v C:/Zaxxon/src/Background/Background.h}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <queue>}\par
{\f2 #include <iostream>}\par
{\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include "Entity/Character/Player/Player.h"}\par
{\f2 #include "Entity/Character/Enemy/Enemy.h"}\par
{\f2 #include "Obstacle/Obstacle.h"}\par
{\f2 #include "Wall/Wall.h"}\par
{\f2 #include "ZapWall/ZapWall.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Background}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds all backgrounds and methods to fill each level with content. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Background.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Background/Background.h}
{\xe \v C:/Zaxxon/src/Background/Background.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <queue>}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include <SFML/Graphics.hpp>}\par
00005 {\cf21 #include "Entity/Character/Player/Player.h"}\par
00006 {\cf21 #include "Entity/Character/Enemy/Enemy.h"}\par
00007 {\cf21 #include "Obstacle/Obstacle.h"}\par
00008 {\cf21 #include "Wall/Wall.h"}\par
00009 {\cf21 #include "ZapWall/ZapWall.h"}\par
00010 \par
00011 \par
00015 {\cf17 class }Background\par
00016 \{\par
00017 {\cf17 public}:\par
00018     {\cf17 enum} Stage\par
00019     \{\par
00020         INITIAL = 0,\par
00021         SPACE = 1,\par
00022         BOSS = 2,\par
00023         BOSSFIGHT = 3\par
00024     \};\par
00025 \par
00026     Background(Stage, sf::View&, sf::Texture*, std::vector<Obstacle*>&,\par
00027                std::vector<Enemy*>&, Player&, {\cf18 int}, std::vector<Wall*>&,\par
00028                std::vector<ZapWall*>&);\par
00029     ~Background();\par
00030 \par
00031     {\cf18 void} update(sf::RenderWindow&, sf::View&, {\cf18 float}, sf::Texture*,\par
00032                 std::vector<Obstacle*>&, std::vector<Enemy*>&, Player&,\par
00033                 std::vector<Wall*>&, std::vector<ZapWall*>&);\par
00034     {\cf18 void} setPosition(sf::Vector2f);\par
00035     {\cf18 void} generateObstacles(Stage,\par
00036                            std::vector<Obstacle*>&, sf::Texture*,\par
00037                            std::vector<Wall*>&, std::vector<ZapWall*>&);\par
00038     {\cf18 void} generateWaves(Stage,\par
00039                        std::vector<Enemy*>&, sf::Texture*, {\cf18 int});\par
00040     {\cf18 void} resetPos(sf::View&, Player&, {\cf18 int});\par
00041 \par
00042     Stage getStage();\par
00043     {\cf18 void} setStage(Stage);\par
00044 \par
00045     {\cf18 bool} isInSpace({\cf18 int});\par
00046 \par
00047     {\cf18 void} flashColor(sf::RenderWindow&);\par
00048 \par
00049 {\cf17 private}:\par
00050     {\cf18 void} changeStage(Stage, sf::View&, sf::Texture*,\par
00051                      std::vector<Obstacle*>&, std::vector<Enemy*>&, Player&,\par
00052                      {\cf18 int}, std::vector<Wall*>&, std::vector<ZapWall*>&);\par
00053     {\cf18 bool} backgroundFinished(sf::View&);\par
00054 \par
00055     sf::Texture initial, space, boss, death;\par
00056     sf::Sprite back;\par
00057     sf::Sprite deathOverlay;\par
00058     Stage stage = INITIAL;\par
00059     std::queue<std::pair<int, unsigned int>> waveQueue; {\cf20 // playerZ: id}\par
00060 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.cpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AbstractBullet.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AbstractBullet.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AbstractBullet.h"}\par
00002 \par
00003 \par
00008 {\cf18 bool} AbstractBullet::isHit()\par
00009 \{\par
00010     {\cf19 return} !alive;\par
00011 \}\par
00012 \par
00013 \par
00018 {\cf18 void} AbstractBullet::translate({\cf18 float} movement)\par
00019 \{\par
00020     setPos(sf::Vector3f(getPos().x, getPos().y, getPos().z + (movement)));\par
00021     sprite->setPosition(translateTo2d(getPos()));\par
00022 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.h}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Entity.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AbstractBullet}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to hold information that the other bullets share. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AbstractBullet.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/AbstractBullet.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "../Entity.h"}\par
00003 \par
00004 \par
00008 {\cf17 class }AbstractBullet : {\cf17 public} Entity\par
00009 \{\par
00010 {\cf17 public}:\par
00011     {\cf17 enum} BulletType\par
00012     \{\par
00013         Player,\par
00014         Enemy,\par
00015         Missile,\par
00016         zBullet,\par
00017         xBulletL,\par
00018         xBulletR\par
00019     \};\par
00020 \par
00021     AbstractBullet() : Entity() \{\}\par
00022 \par
00023     {\cf18 bool} isHit();\par
00024     {\cf18 void} translate({\cf18 float});\par
00025 {\cf17 protected}:\par
00026     {\cf18 bool} alive = {\cf17 true};\par
00027 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "BossBullet.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BossBullet.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "BossBullet.h"}\par
00002 {\cf21 #include <iostream>}\par
00003 \par
00004 \par
00011 BossBullet::BossBullet(sf::Vector3f startPos, Entity* target,\par
00012                        sf::Texture* spriteSheet)\par
00013 \{\par
00014     this->target = target;\par
00015 \par
00016     sprite->setTexture(*spriteSheet);\par
00017     sprite->setTextureRect(sf::IntRect(38, 74, 39, 27));\par
00018     sprite->setOrigin(sf::Vector2f(0, sprite->getGlobalBounds().height));\par
00019 \par
00020     sprite->setPosition(translateTo2d(startPos));\par
00021 \par
00022     setPos(startPos);\par
00023 \par
00024     movementInt.restart();\par
00025     invTimer.restart();\par
00026 \}\par
00027 \par
00028 \par
00033 {\cf18 void} BossBullet::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00034 \{\par
00035     {\cf20 //moves toward the target(player) in a similar manner to the boss}\par
00036     {\cf19 if} (movementInt.getElapsedTime().asMilliseconds() >= 50 && animations.\par
00037         getState() == 0)\par
00038     \{\par
00039         movementInt.restart();\par
00040 \par
00041         {\cf19 if} ((target->getPos().x - 50) - getPos().x > 5)\par
00042             setPos(sf::Vector3f(getPos().x + 5 * gameSpeed, getPos().y,\par
00043                                 getPos().z));\par
00044         {\cf19 if} ((target->getPos().x - 50) - getPos().x < 5)\par
00045             setPos(sf::Vector3f(getPos().x - 5 * gameSpeed, getPos().y,\par
00046                                 getPos().z));\par
00047 \par
00048         {\cf19 if} (target->getPos().y - getPos().y > 3)\par
00049             setPos(sf::Vector3f(getPos().x, getPos().y + 5 * gameSpeed,\par
00050                                 getPos().z));\par
00051         {\cf19 if} (target->getPos().y - getPos().y < 3)\par
00052             setPos(sf::Vector3f(getPos().x, getPos().y - 5 * gameSpeed,\par
00053                                 getPos().z));\par
00054 \par
00055         translate(3.5f);\par
00056     \}\par
00057 \par
00058     {\cf20 //if the bullet dies treat it as a collision}\par
00059     {\cf19 if} (health <= 0)\par
00060         alive = {\cf17 false};\par
00061 \par
00062     window.draw(*sprite);\par
00063 \}\par
00064 \par
00065 \par
00069 {\cf18 void} BossBullet::collide()\par
00070 \{\par
00071     {\cf19 if} (animations.getState() == 0)\par
00072     \{\par
00073         animations.run(sprite, Animation::ALT_DEATH);\par
00074     \}\par
00075 \par
00076     alive = {\cf17 false};\par
00077 \}\par
00078 \par
00079 \par
00084 {\cf18 void} BossBullet::damage({\cf18 int} hit)\par
00085 \{\par
00086     {\cf19 if} (invTimer.getElapsedTime().asMilliseconds() >= 75)\par
00087     \{\par
00088         invTimer.restart();\par
00089         health -= hit;\par
00090     \}\par
00091 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.h}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../AbstractBullet.h"}\par
{\f2 #include "Entity/Character/Player/Player.h"}\par
{\f2 #include "SFML/Graphics.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BossBullet}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The missile that the boss shoots. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BossBullet.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/BossBullet/BossBullet.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "../AbstractBullet.h"}\par
00003 {\cf21 #include "Entity/Character/Player/Player.h"}\par
00004 {\cf21 #include "SFML/Graphics.hpp"}\par
00005 \par
00006 \par
00010 {\cf17 class }BossBullet : {\cf17 public} AbstractBullet\par
00011 \{\par
00012 {\cf17 public}:\par
00013     BossBullet(sf::Vector3f, Entity*, sf::Texture*);\par
00014 \par
00015     {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) {\cf17 override};\par
00016     {\cf18 void} damage({\cf18 int});\par
00017     {\cf18 void} collide();\par
00018 {\cf17 private}:\par
00019     Entity* target;\par
00020     sf::Clock movementInt, invTimer;\par
00021     {\cf18 int} health = 6;\par
00022 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.cpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CharacterBullet.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CharacterBullet.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "CharacterBullet.h"}\par
00002 \par
00003 \par
00016 CharacterBullet::CharacterBullet(sf::Texture* spritesheet,\par
00017                                  sf::Vector3f spawnPos,\par
00018                                  {\cf18 unsigned} {\cf18 int} sizeIndex, BulletType type,\par
00019                                  sf::Vector2f spawnPos2f\par
00020 )\par
00021 \{\par
00022     sprite->setTexture(*spritesheet);\par
00023     sprite->setTextureRect(sf::IntRect(8 + 16 * sizeIndex, 47, 16, 8));\par
00024     sprite->setOrigin(0, 8);\par
00025 \par
00026     {\cf19 if} (type == Player)\par
00027     \{\par
00028         sprite->setColor(sf::Color(0, 222, 0));\par
00029         setPos(sf::Vector3f(spawnPos.x - 21.f, spawnPos.y + .02f * sizeIndex,\par
00030                             spawnPos.z - 15.f));\par
00031         sprite->setPosition(translateTo2d(getPos()));\par
00032     \}\par
00033     {\cf19 else} {\cf19 if} (type == Enemy)\par
00034     \{\par
00035         sprite->setColor(sf::Color(222, 0, 0));\par
00036         sprite->setPosition(\par
00037             spawnPos2f + sf::Vector2f(-3.f * {\cf17 static_cast<}{\cf18 int}{\cf17 >}(3U - sizeIndex),\par
00038                                       20));\par
00039     \}\par
00040     this->sizeIndex = sizeIndex;\par
00041     this->type = type;\par
00042 \}\par
00043 \par
00044 \par
00049 {\cf18 unsigned} {\cf18 int} CharacterBullet::getSizeIndex()\par
00050 \{\par
00051     {\cf19 return} sizeIndex;\par
00052 \}\par
00053 \par
00054 \par
00058 {\cf18 void} CharacterBullet::kill()\par
00059 \{\par
00060     kill(EnemyDeath);\par
00061 \}\par
00062 \par
00063 \par
00068 {\cf18 void} CharacterBullet::kill(BulletDeathType deathType)\par
00069 \{\par
00070     sprite->setColor(sf::Color(255, 255, 255));\par
00071     {\cf20 //death conditions and animations based on what is dying}\par
00072     {\cf19 switch} (deathType)\par
00073     \{\par
00074     {\cf19 case} WallDeath:\par
00075         {\cf19 if} (animations.getState() < 1)\par
00076             animations.run(sprite, Animation::Anim::WALLBULLET_DEATH,\par
00077                            sizeIndex);\par
00078         {\cf19 break};\par
00079     {\cf19 case} EnemyDeath:\par
00080         {\cf20 // adjust position to align better}\par
00081         {\cf19 if} (this->type == Player)\par
00082             setPos(getPos() + sf::Vector3f(0, 0, -16));\par
00083         {\cf19 if} (animations.getState() < 2)\par
00084             animations.run(sprite, Animation::Anim::BULLET_DEATH, sizeIndex);\par
00085     \}\par
00086 \}\par
00087 \par
00088 \par
00093 {\cf18 void} CharacterBullet::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00094 \{\par
00095     {\cf19 if} (type == Player)\par
00096     \{\par
00097         {\cf19 if} (animations.getState() == 0)\par
00098         \{\par
00099             translate(-6 * gameSpeed);\par
00100         \}\par
00101     \}\par
00102     {\cf20 //doesn't use translate because it uses 2d movement}\par
00103     {\cf19 else} {\cf19 if} (type == Enemy)\par
00104         sprite->move(translateTo2d(sf::Vector3f(0, 0, 3 * gameSpeed)));\par
00105 \par
00106     {\cf19 if} (animations.getState() == 1)\par
00107         alive = {\cf17 false};\par
00108 \par
00109     window.draw(*sprite);\par
00110 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.h}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../AbstractBullet.h"}\par
{\f2 #include "Util/Util.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CharacterBullet}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bullet used by the player and enemies. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CharacterBullet.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/CharacterBullet/CharacterBullet.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "../AbstractBullet.h"}\par
00003 {\cf21 #include "Util/Util.h"}\par
00004 \par
00005 \par
00009 {\cf17 class }CharacterBullet : {\cf17 public} AbstractBullet\par
00010 \{\par
00011 {\cf17 public}:\par
00012     {\cf17 enum} BulletDeathType\par
00013     \{\par
00014         WallDeath,\par
00015         EnemyDeath,\par
00016         MissileDeath\par
00017     \};\par
00018 \par
00019     CharacterBullet(sf::Texture* spritesheet, sf::Vector3f spawnPos,\par
00020                     {\cf18 unsigned} {\cf18 int} sizeindex, BulletType = Player,\par
00021                     sf::Vector2f = sf::Vector2f(0, 0)\par
00022     );\par
00023 \par
00024     {\cf18 void} kill();\par
00025     {\cf18 void} kill(BulletDeathType type);\par
00026     {\cf18 void} update(sf::RenderWindow& window, {\cf18 float}) {\cf17 override};\par
00027     {\cf18 unsigned} {\cf18 int} getSizeIndex();\par
00028 {\cf17 private}:\par
00029     {\cf18 unsigned} {\cf18 int} sizeIndex;\par
00030     BulletType type;\par
00031 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.cpp}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ObstacleBullet.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ObstacleBullet.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.cpp}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ObstacleBullet.h"}\par
00002 \par
00009 ObstacleBullet::ObstacleBullet(sf::Vector3f pos, sf::Texture* spriteSheet,\par
00010                                BulletType type)\par
00011 \{\par
00012     sprite->setTexture(*spriteSheet);\par
00013 \par
00014     {\cf20 //checks for the bullet direction}\par
00015     {\cf19 switch} (type)\par
00016     \{\par
00017     {\cf19 case} xBulletR:\par
00018         sprite->setTextureRect(sf::IntRect(345, 124, 14, 9));\par
00019         sprite->setOrigin(sf::Vector2f(sprite->getGlobalBounds().width,\par
00020             sprite->getGlobalBounds().height));\par
00021         {\cf19 break};\par
00022     {\cf19 case} xBulletL:\par
00023         sprite->setTextureRect(sf::IntRect(345, 124, 14, 9));\par
00024         sprite->setOrigin(sf::Vector2f(0, 0));\par
00025         {\cf19 break};\par
00026     {\cf19 case} zBullet:\par
00027         sprite->setTextureRect(sf::IntRect(160, 127, 14, 9));\par
00028         sprite->setOrigin(sf::Vector2f(0, sprite->getGlobalBounds().height));\par
00029         {\cf19 break};\par
00030     {\cf19 default}:\par
00031         {\cf19 break};\par
00032     \}\par
00033 \par
00034     setPos(pos);\par
00035     sprite->setPosition(translateTo2d(getPos()));\par
00036 \par
00037     this->type = type;\par
00038 \}\par
00039 \par
00040 \par
00046 {\cf18 void} ObstacleBullet::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00047 \{\par
00048     {\cf20 //change movement based on type}\par
00049     {\cf19 switch} (type)\par
00050     \{\par
00051     {\cf19 case} xBulletL:\par
00052         setPos(sf::Vector3f(getPos().x + 3 * gameSpeed, getPos().y,\par
00053                             getPos().z));\par
00054         sprite->setPosition(translateTo2d(getPos()));\par
00055         {\cf19 break};\par
00056     {\cf19 case} xBulletR:\par
00057         setPos(sf::Vector3f(getPos().x - 3 * gameSpeed, getPos().y,\par
00058                             getPos().z));\par
00059         sprite->setPosition(translateTo2d(getPos()));\par
00060         {\cf19 break};\par
00061     {\cf19 case} zBullet:\par
00062         translate(3 * gameSpeed);\par
00063     \}\par
00064 \par
00065     window.draw(*sprite);\par
00066 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SFML/Graphics.hpp"}\par
{\f2 #include "../AbstractBullet.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ObstacleBullet}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ObstacleBullet.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h}
{\xe \v C:/Zaxxon/src/Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "SFML/Graphics.hpp"}\par
00003 {\cf21 #include "../AbstractBullet.h"}\par
00004 \par
00005 \par
00006 {\cf17 class }ObstacleBullet : {\cf17 public} AbstractBullet\par
00007 \{\par
00008 {\cf17 public}:\par
00009     ObstacleBullet(sf::Vector3f, sf::Texture*, BulletType);\par
00010 \par
00011     {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) {\cf17 override};\par
00012 {\cf17 private}:\par
00013     BulletType type;\par
00014 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Boss/Boss.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Boss/Boss.cpp}
{\xe \v C:/Zaxxon/src/Entity/Boss/Boss.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Boss.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Boss.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Boss/Boss.cpp}
{\xe \v C:/Zaxxon/src/Entity/Boss/Boss.cpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Boss.h"}\par
00002 \par
00003 \par
00011 Boss::Boss(sf::Vector3f start, Entity* target, sf::Texture* bossSheet,\par
00012            sf::Texture* spriteSheet) : Entity()\par
00013 \{\par
00014     setPos(start);\par
00015 \par
00016     sprite->setPosition(translateTo2d(start));\par
00017     sprite->setTexture(*bossSheet);\par
00018     sprite->setTextureRect(sf::IntRect(0, 0, 58, 75));\par
00019     sprite->setOrigin(\par
00020         sf::Vector2f(0, sprite->getGlobalBounds().height * (3.f / 4.f)));\par
00021 \par
00022     this->target = target;\par
00023 \par
00024     this->spriteSheet = spriteSheet;\par
00025 \par
00026     movementInt.restart();\par
00027 \par
00028     {\cf20 //defines random movement, goes to two seperate points}\par
00029     targetXPoints[0] = (rand() % 100) * -1.f;\par
00030     targetXPoints[1] = (abs((rand() - 528) * 72) % 100) * -1.f;\par
00031 \par
00032     {\cf20 //timer for invincibility frames}\par
00033     invFrames.restart();\par
00034 \}\par
00035 \par
00036 \par
00040 Boss::~Boss()\par
00041 \{\par
00042     {\cf17 delete} missile;\par
00043 \}\par
00044 \par
00045 \par
00050 {\cf18 void} Boss::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00051 \{\par
00052     {\cf19 if} (movementInt.getElapsedTime().asMilliseconds() >= 100)\par
00053     \{\par
00054         {\cf20 //moves to the target position every 100 millisecond to mimic gittery }\par
00055         {\cf20 //movment of the game}\par
00056         movementInt.restart();\par
00057 \par
00058         {\cf19 if} (targetXPoints[stages] - getPos().x > 3)\par
00059             setPos(sf::Vector3f(getPos().x + 3, getPos().y, getPos().z));\par
00060 \par
00061         {\cf19 if} (targetXPoints[stages] - getPos().x < 3)\par
00062             setPos(sf::Vector3f(getPos().x - 3, getPos().y, getPos().z));\par
00063 \par
00064         {\cf19 if} (abs(getPos().z - target->getPos().z) < 250 && stages == 0)\par
00065             stages++;\par
00066 \par
00067         {\cf20 //if the boss is far enough away from the player continue moving it}\par
00068         {\cf19 if} (abs(getPos().z - target->getPos().z) > 150)\par
00069         \{\par
00070             {\cf19 if} (stages < 2)\par
00071                 setPos(sf::Vector3f(getPos().x, getPos().y, getPos().z + 3));\par
00072             {\cf19 else}\par
00073                 setPos(sf::Vector3f(getPos().x, getPos().y, getPos().z - 7));\par
00074         \}\par
00075         {\cf20 //else stop it and shoot the missile}\par
00076         {\cf19 else}\par
00077         \{\par
00078             sprite->setTextureRect(sf::IntRect(58, 0, 58, 75));\par
00079             stages++;\par
00080             setPos(sf::Vector3f(getPos().x, getPos().y, getPos().z - 7));\par
00081 \par
00082             bulletCreated = {\cf17 true};\par
00083             {\cf20 //gives the missile the position of the player}\par
00084             missile = {\cf17 new} BossBullet(\par
00085                 sf::Vector3f(getPos().x - 33, getPos().y - 19, getPos().z),\par
00086                 target, spriteSheet);\par
00087             missile->damage(hits);\par
00088         \}\par
00089     \}\par
00090 \par
00091     {\cf20 //detects the hits to the missile and adds the shaking animation}\par
00092     {\cf19 if} (movementInt.getElapsedTime().asMilliseconds() % 25)\par
00093     \{\par
00094         {\cf19 if} (hitCount < 10)\par
00095         \{\par
00096             hitCount++;\par
00097             setPos(sf::Vector3f(getPos().x + ((rand() % 100) / 50.f) - 1,\par
00098                                 getPos().y + ((rand() % 100) / 50.f) - 1,\par
00099                                 getPos().z));\par
00100         \}\par
00101         {\cf19 else} {\cf19 if} (hitCount == 10)\par
00102         \{\par
00103             hitCount++;\par
00104             sprite->setColor(sf::Color(255, 255, 255));\par
00105         \}\par
00106     \}\par
00107 \par
00108     sprite->setPosition(translateTo2d(getPos()));\par
00109 \par
00110     {\cf20 //if it retreats all the way it has been defeated}\par
00111     {\cf19 if} (getPos().z <= -4000 && stages >= 2)\par
00112     \{\par
00113         destroyed = {\cf17 true};\par
00114         stages++;\par
00115     \}\par
00116 \par
00117     targetXPoints[2] = getPos().x;\par
00118 \par
00119     window.draw(*sprite);\par
00120 \par
00121     {\cf20 //if the missile dies delete it and record that action}\par
00122     {\cf19 if} (stages == 2 && missile != {\cf17 nullptr})\par
00123     \{\par
00124         {\cf19 if} (missile->isHit())\par
00125         \{\par
00126             {\cf17 delete} missile;\par
00127             missile = {\cf17 nullptr};\par
00128             bulletCreated = {\cf17 false};\par
00129         \}\par
00130         {\cf19 else}\par
00131             missile->update(window, gameSpeed);\par
00132     \}\par
00133 \}\par
00134 \par
00135 \par
00139 {\cf18 void} Boss::hit()\par
00140 \{\par
00141     {\cf20 //damages the boss and starts the timer of invincibility}\par
00142     {\cf19 if} (invFrames.getElapsedTime().asMilliseconds() >= 200)\par
00143     \{\par
00144         invFrames.restart();\par
00145         hitCount = 0;\par
00146         sprite->setColor(sf::Color(225, 100, 100));\par
00147         hits++;\par
00148         {\cf19 if} (hits >= 10)\par
00149         \{\par
00150             sprite->setTextureRect(sf::IntRect(58, 0, 58, 75));\par
00151             stages = 3;\par
00152         \}\par
00153     \}\par
00154 \}\par
00155 \par
00156 \par
00161 BossBullet* Boss::getMissile(){\cf17  const}\par
00162 {\cf17 }\{\par
00163     {\cf19 return} missile;\par
00164 \}\par
00165 \par
00166 \par
00171 {\cf18 bool} Boss::missileCreated(){\cf17  const}\par
00172 {\cf17 }\{\par
00173     {\cf19 return} bulletCreated;\par
00174 \}\par
00175 \par
00176 \par
00181 {\cf18 bool} Boss::isDestroyed(){\cf17  const}\par
00182 {\cf17 }\{\par
00183     {\cf19 return} destroyed;\par
00184 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Boss/Boss.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Boss/Boss.h}
{\xe \v C:/Zaxxon/src/Entity/Boss/Boss.h}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SFML/Graphics.hpp"}\par
{\f2 #include "Entity/Entity.h"}\par
{\f2 #include "Util/Util.h"}\par
{\f2 #include "Entity/AbstractBullet/BossBullet/BossBullet.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Boss}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The boss entity you fight at the end of the level loop. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Boss.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Boss/Boss.h}
{\xe \v C:/Zaxxon/src/Entity/Boss/Boss.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "SFML/Graphics.hpp"}\par
00003 {\cf21 #include "Entity/Entity.h"}\par
00004 {\cf21 #include "Util/Util.h"}\par
00005 {\cf21 #include "Entity/AbstractBullet/BossBullet/BossBullet.h"}\par
00006 \par
00007 \par
00011 {\cf17 class }Boss : {\cf17 public} Entity\par
00012 \{\par
00013 {\cf17 public}:\par
00014     Boss(sf::Vector3f, Entity*, sf::Texture*, sf::Texture*);\par
00015     ~Boss() {\cf17 override};\par
00016 \par
00017     {\cf18 void} update(sf::RenderWindow&, {\cf18 float} gameSpeed) {\cf17 override};\par
00018     {\cf18 void} hit();\par
00019     BossBullet* getMissile() {\cf17 const};\par
00020     {\cf18 bool} missileCreated() {\cf17 const};\par
00021     {\cf18 bool} isDestroyed() {\cf17 const};\par
00022 {\cf17 private}:\par
00023     Entity* target;\par
00024     sf::Clock movementInt, invFrames;\par
00025     {\cf18 int} stages = 0, hitCount = 20, hits = 0;\par
00026 \par
00027     BossBullet* missile = {\cf17 nullptr};\par
00028     {\cf18 bool} bulletCreated = {\cf17 false}, destroyed = {\cf17 false};\par
00029     {\cf18 float} targetXPoints[3];\par
00030 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Character.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Character.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Character.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Character.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Character.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Character.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Character.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Character.h"}\par
00002 \par
00003 \par
00008 Character::Character(sf::Texture* spriteSheet) : Entity()\par
00009 \{\par
00010     this->spriteSheet = spriteSheet;\par
00011     this->sprite->setTexture(*this->spriteSheet);\par
00012     this->sizeIndex = 0;\par
00013 \}\par
00014 \par
00015 \par
00019 Character::~Character()\par
00020 \{\par
00021     {\cf17 const} {\cf18 int} bulletSize = bullets.size();\par
00022     {\cf19 for} ({\cf18 int} i = 0; i < bulletSize; i++)\par
00023         {\cf17 delete} bullets[i];\par
00024 \}\par
00025 \par
00026 \par
00031 {\cf18 void} Character::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00032 \{\par
00033     {\cf20 // update the character's position using its velocity}\par
00034     setPos(getPos() + this->velocity * gameSpeed);\par
00035 \par
00036     sprite->setPosition(translateTo2d(getPos()));\par
00037     window.draw(*sprite);\par
00038 \par
00039     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < bullets.size(); i++)\par
00040     \{\par
00041         {\cf19 if} (bullets.at(i)->isHit())\par
00042         \{\par
00043             {\cf17 delete} bullets[i];\par
00044             bullets.erase(bullets.begin() + i);\par
00045         \}\par
00046     \}\par
00047 \}\par
00048 \par
00049 \par
00054 std::vector<CharacterBullet*>& Character::getBullets()\par
00055 \{\par
00056     {\cf19 return} bullets;\par
00057 \}\par
00058 \par
00059 \par
00064 {\cf18 unsigned} {\cf18 int} Character::getSizeIndex(){\cf17  const}\par
00065 {\cf17 }\{\par
00066     {\cf19 return} sizeIndex;\par
00067 \}\par
00068 \par
00069 \par
00076 {\cf18 void} Character::_getSizeIndex({\cf18 unsigned} {\cf18 int}& planeSizeIndex)\par
00077 \{\par
00078     {\cf17 const} {\cf18 float} y = abs(getPos().y - {\cf17 static_cast<}{\cf18 float}{\cf17 >}(yMax));\par
00079     {\cf17 const} {\cf18 float} qSize = abs((yMax - yMin) / 4.f);\par
00080     planeSizeIndex = 3; {\cf20 // smallest}\par
00081 \par
00082     {\cf19 for} ({\cf18 int} i = 1; i < 4; i++)\par
00083         {\cf19 if} (y > qSize * i && y < qSize * (i + 1))\par
00084             planeSizeIndex = 3 - i;\par
00085 \par
00086     {\cf19 if} (getPos().y >= yMax)\par
00087         planeSizeIndex = 3;\par
00088     {\cf19 if} (getPos().y <= yMin)\par
00089         planeSizeIndex = 0;\par
00090 \}\par
00091 \par
00092 \par
00097 sf::Vector3f Character::getVelocity(){\cf17  const}\par
00098 {\cf17 }\{\par
00099     {\cf19 return} velocity;\par
00100 \}\par
00101 \par
00102 \par
00107 {\cf18 void} Character::setBullet(sf::IntRect bulletTexture)\par
00108 \{\par
00109     this->bulletTexture = bulletTexture;\par
00110 \}\par
00111 \par
00112 \par
00117 {\cf18 void} Character::setVelocity(sf::Vector3f vel)\par
00118 \{\par
00119     this->velocity = vel;\par
00120 \}\par
00121 \par
00122 \par
00128 {\cf18 void} Character::updateBullets(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00129 \{\par
00130     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < bullets.size(); i++)\par
00131     \{\par
00132         CharacterBullet* bullet = bullets[i];\par
00133         bullet->update(window, gameSpeed);\par
00134 \par
00135         {\cf19 if} (!getWindowViewRect(window).intersects(bullet->getBounds()) || bullet->\par
00136             getAnimationState() == 1)\par
00137         \{\par
00138             {\cf17 delete} bullet;\par
00139             bullets.erase(bullets.begin() + i);\par
00140             i--;\par
00141         \}\par
00142     \}\par
00143 \}\par
00144 \par
00145 \par
00150 {\cf18 void} Character::killBullet({\cf18 int} bullet)\par
00151 \{\par
00152     {\cf17 delete} bullets[bullet];\par
00153     bullets.erase(bullets.begin() + bullet);\par
00154 \}\par
00155 \par
00156 \par
00161 {\cf18 void} Character::setPos(sf::Vector3f pos)\par
00162 \{\par
00163     {\cf19 if} (pos.y >= yMax)\par
00164         pos.y = yMax - 1.f;\par
00165     {\cf19 else} {\cf19 if} (pos.y <= yMin)\par
00166         pos.y = yMin + 1.f;\par
00167 \par
00168     Entity::setPos(pos);\par
00169     sprite->setPosition(translateTo2d(getPos()));\par
00170 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Character.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Character.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Character.h}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include "Util/Util.h"}\par
{\f2 #include "Animation/Animation.h"}\par
{\f2 #include "Entity/Entity.h"}\par
{\f2 #include "Entity/AbstractBullet/CharacterBullet/CharacterBullet.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Character}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to hold information that both player and enemy use. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Character.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Character.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Character.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 {\cf21 #include "Util/Util.h"}\par
00004 {\cf21 #include "Animation/Animation.h"}\par
00005 {\cf21 #include "Entity/Entity.h"}\par
00006 {\cf21 #include "Entity/AbstractBullet/CharacterBullet/CharacterBullet.h"}\par
00007 \par
00008 \par
00012 {\cf17 class }Character : {\cf17 public} Entity\par
00013 \{\par
00014 {\cf17 public}:\par
00015     Character(sf::Texture*);\par
00016     ~Character() {\cf17 override};\par
00017     {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) {\cf17 override};\par
00018     {\cf17 virtual} {\cf18 void} kill() = 0;\par
00019 \par
00020     std::vector<CharacterBullet*>& getBullets();\par
00021     {\cf18 unsigned} {\cf18 int} getSizeIndex() {\cf17 const};\par
00022     {\cf18 void} killBullet({\cf18 int});\par
00023 \par
00024     {\cf18 void} setPos(sf::Vector3f);\par
00025 {\cf17 protected}:\par
00026     {\cf17 const} {\cf18 int} yMax = 140;\par
00027     {\cf17 const} {\cf18 int} yMin = 69;\par
00028     {\cf17 const} {\cf18 int} xMin = -160;\par
00029     {\cf17 const} {\cf18 int} xMax = 0;\par
00030 \par
00031     {\cf18 void} _getSizeIndex({\cf18 unsigned} {\cf18 int}&);\par
00032     sf::Vector3f getVelocity() {\cf17 const};\par
00033 \par
00034     {\cf18 void} setVelocity(sf::Vector3f);\par
00035     {\cf18 void} setBullet(sf::IntRect);\par
00036 \par
00037     {\cf18 void} updateBullets(sf::RenderWindow& window, {\cf18 float});\par
00038 \par
00039     sf::Vector3f velocity;\par
00040     std::vector<CharacterBullet*> bullets;\par
00041     {\cf18 unsigned} {\cf18 int} sizeIndex;\par
00042 {\cf17 private}:\par
00043     sf::IntRect bulletTexture;\par
00044 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Enemy/Enemy.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.cpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Enemy.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Enemy.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Enemy.h"}\par
00002 \par
00003 \par
00010 Enemy::Enemy(sf::Texture* texture, {\cf18 unsigned} {\cf18 int} {\cf18 id}, sf::Vector3f spawnPos,\par
00011              {\cf18 int} randOffset) : Character(texture)\par
00012 \{\par
00013     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < 2; i++)\par
00014         {\cf19 for} ({\cf18 unsigned} {\cf18 int} j = 0; j < 4; j++)\par
00015             textures[i][j] = sf::IntRect(96 + 25 * j + i * 100, 37, 25, 25);\par
00016     this->sprite->setTextureRect(textures[0][0]);\par
00017     this->{\cf18 id} = id;\par
00018     this->randOffset = randOffset;\par
00019     {\cf18 int} spawnZ = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(spawnPos.z);\par
00020     alive.restart();\par
00021     sf::Vector3f pos;\par
00022 \par
00023     {\cf20 // y range @ current values: 0 - 71.}\par
00024     {\cf19 switch} ({\cf18 id})\par
00025     \{\par
00026     {\cf19 case} 0:\par
00027         pos = sf::Vector3f(120, 25, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00028         {\cf19 break};\par
00029     {\cf19 case} 1:\par
00030         pos = sf::Vector3f(-30, 45, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00031         {\cf19 break};\par
00032     {\cf19 case} 2:\par
00033         pos = sf::Vector3f(-60, 55, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00034         {\cf19 break};\par
00035     {\cf19 case} 3:\par
00036         pos = sf::Vector3f(-90, 65, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00037         {\cf19 break};\par
00038     {\cf19 case} 4:\par
00039         pos = sf::Vector3f(0, 71, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00040         {\cf19 break};\par
00041     {\cf19 case} 5:\par
00042         pos = sf::Vector3f(-210, 71, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00043         {\cf19 break};\par
00044     {\cf19 case} 6:\par
00045         pos = sf::Vector3f(-160, 45, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(spawnZ));\par
00046         {\cf19 break};\par
00047     {\cf19 case} 7:\par
00048         pos = spawnPos;\par
00049     \}\par
00050     this->setPos(pos + sf::Vector3f(0, 69, 0));\par
00051 \}\par
00052 \par
00053 \par
00058 {\cf18 void} Enemy::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00059 \{\par
00060     {\cf20 // Find velocity}\par
00061     sf::Vector2f vel = runAI();\par
00062 \par
00063     {\cf20 // Shooting}\par
00064     {\cf19 if} ((!dead &&\par
00065             ableToFire &&\par
00066             bulletCD.getElapsedTime().asMilliseconds() > 250\par
00067             && rand() % 125 == 0)\par
00068 #ifndef NDEBUG\par
00069         || (sf::Keyboard::isKeyPressed(sf::Keyboard::R))\par
00070 #endif\par
00071     )\par
00072     \{\par
00073         bulletCD.restart();\par
00074 \par
00075         bullets.push_back({\cf17 new} CharacterBullet(spriteSheet, getPos(), sizeIndex,\par
00076                                               CharacterBullet::Enemy,\par
00077                                               this->sprite->getPosition())\par
00078         );\par
00079     \}\par
00080 \par
00081     {\cf18 unsigned} {\cf18 int} planeVertical = vel.y > 0;\par
00082 \par
00083     {\cf20 // Moved to keep up with back}\par
00084     sprite->move(translateTo2d(sf::Vector3f(0, 0, -1.3f * gameSpeed * 2 / 3)));\par
00085     sprite->setTextureRect(textures[planeVertical][sizeIndex]);\par
00086 \par
00087     updateBullets(window, gameSpeed);\par
00088     {\cf19 if} (!dead)\par
00089         window.draw(*sprite);\par
00090 \}\par
00091 \par
00092 \par
00097 {\cf18 unsigned} {\cf18 int} Enemy::getSizeIndex()\par
00098 \{\par
00099     {\cf19 return} sizeIndex;\par
00100 \}\par
00101 \par
00102 \par
00106 {\cf18 void} Enemy::kill()\par
00107 \{\par
00108     this->dead = {\cf17 true};\par
00109 \}\par
00110 \par
00111 \par
00119 {\cf18 void} Enemy::spawnWave(std::vector<Enemy*>& enemies, sf::Texture* spritesheet,\par
00120                       {\cf18 int} playerZ, {\cf18 unsigned} {\cf18 int} wave)\par
00121 \{\par
00122     {\cf19 switch} (wave)\par
00123     \{\par
00124     {\cf19 case} 0:\par
00125         {\cf20 // first fish loop}\par
00126         enemies.push_back({\cf17 new} Enemy(spritesheet, 0,\par
00127                                     sf::Vector3f(0, 0, playerZ - 190.f)));\par
00128         {\cf19 break};\par
00129     {\cf19 case} 1:\par
00130     {\cf19 case} 2:\par
00131     {\cf19 case} 3:\par
00132     {\cf19 case} 4:\par
00133         {\cf20 // first right->charge (top right)}\par
00134         enemies.push_back({\cf17 new} Enemy(spritesheet, wave,\par
00135                                     sf::Vector3f(0, 0, playerZ - 360.f),\par
00136                                     rand() % 600 - 300));\par
00137         {\cf19 break};\par
00138     {\cf19 case} 5:\par
00139     {\cf19 case} 6:\par
00140         {\cf20 // (bottom left)}\par
00141         enemies.push_back({\cf17 new} Enemy(spritesheet, wave,\par
00142                                     sf::Vector3f(0, 0, playerZ - 190.f),\par
00143                                     rand() % 600 - 300));\par
00144         {\cf19 break};\par
00145     {\cf19 case} 7: {\cf20 // 3 ememies from top right}\par
00146         {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00147             enemies.push_back({\cf17 new} Enemy(spritesheet, wave,\par
00148                                         sf::Vector3f(\par
00149                                             35.f - 70.f * i, 0,\par
00150                                             playerZ - 360.f),\par
00151                                         rand() % 600 - 300));\par
00152     \}\par
00153 \}\par
00154 \par
00155 \par
00159 sf::Vector2f Enemy::runAI()\par
00160 \{\par
00161     sf::Vector2f vel;\par
00162     sf::Int32 msPassed = alive.getElapsedTime().asMilliseconds();\par
00163     {\cf18 float} theta = 0;\par
00164     {\cf18 float} scale = 1;\par
00165     sf::Vector2f transl;\par
00166 \par
00167     {\cf20 // size index 0-3 controls size: 0 biggest, 3 smallest}\par
00168     {\cf20 // theta and scale represent polar coordinates.}\par
00169     {\cf19 switch} ({\cf18 id})\par
00170     \{\par
00171     {\cf19 case} 0: {\cf20 // fish loop}\par
00172         scale = 1.7f;\par
00173 \par
00174         {\cf19 if} (msPassed < 1500)\par
00175         \{\par
00176             theta = -60;\par
00177             {\cf19 if} (msPassed < 600)\par
00178                 sizeIndex = 1;\par
00179             {\cf19 else} {\cf19 if} (msPassed < 1200)\par
00180                 sizeIndex = 2;\par
00181             {\cf19 else}\par
00182                 sizeIndex = 3;\par
00183         \}\par
00184         {\cf19 else} {\cf19 if} (msPassed < 2500)\par
00185         \{\par
00186             theta = (msPassed - 1500) / 2800.f * 360;\par
00187             theta = theta * PI / 180.f;\par
00188             transl.x = cos(theta) * scale;\par
00189             transl.y = 1.25f * -sin(theta) * scale; {\cf20 // eliptical}\par
00190             theta = 0;\par
00191         \}\par
00192         {\cf19 else} {\cf19 if} (msPassed < 5000)\par
00193         \{\par
00194             {\cf20 // add 4k for starting pos of circle}\par
00195             theta = (msPassed - 3400 + 4500) / 7500.f * 360;\par
00196             {\cf19 if} (msPassed < 3500)\par
00197                 sizeIndex = 2;\par
00198             {\cf19 else}\par
00199                 sizeIndex = 3;\par
00200         \}\par
00201         {\cf19 else}\par
00202         \{\par
00203             theta = 180 + 60;\par
00204         \}\par
00205         {\cf19 break};\par
00206     {\cf19 case} 1: {\cf20 // come from right then up little then charge}\par
00207     {\cf19 case} 2:\par
00208     {\cf19 case} 3:\par
00209         {\cf19 if} (msPassed < 1500)\par
00210         \{\par
00211             sizeIndex = 3;\par
00212             theta = 180 + 30;\par
00213         \}\par
00214         {\cf19 else} {\cf19 if} (msPassed < 2500)\par
00215         \{\par
00216             theta = 90;\par
00217             {\cf19 if} (msPassed < 1800)\par
00218                 sizeIndex = 2;\par
00219             {\cf19 else} {\cf19 if} (msPassed < 2100)\par
00220                 sizeIndex = 1;\par
00221             {\cf19 else} {\cf19 if} (msPassed < 2500)\par
00222                 sizeIndex = 0;\par
00223         \}\par
00224         {\cf19 else} {\cf19 if} (msPassed < 5500)\par
00225         \{\par
00226             theta = 180 + 40;\par
00227             {\cf19 if} (msPassed < 3200)\par
00228                 sizeIndex = 0;\par
00229             {\cf19 else} {\cf19 if} (msPassed < 3900)\par
00230                 sizeIndex = 1;\par
00231             {\cf19 else} {\cf19 if} (msPassed < 4500)\par
00232                 sizeIndex = 2;\par
00233             {\cf19 else}\par
00234                 sizeIndex = 3;\par
00235         \}\par
00236         {\cf19 else}\par
00237         \{\par
00238             theta = 180;\par
00239         \}\par
00240         {\cf19 break};\par
00241     {\cf19 case} 4: {\cf20 // come from top right then down little then charge}\par
00242         {\cf19 if} (msPassed < 750 + randOffset)\par
00243         \{\par
00244             sizeIndex = 0;\par
00245             theta = 180 - 15;\par
00246         \}\par
00247         {\cf19 else} {\cf19 if} (msPassed < 2500 + randOffset * 2)\par
00248         \{\par
00249             theta = -90;\par
00250             scale = 0.6f;\par
00251             {\cf19 if} (msPassed < 1000)\par
00252                 sizeIndex = 0;\par
00253             {\cf19 else} {\cf19 if} (msPassed < 1500)\par
00254                 sizeIndex = 1;\par
00255             {\cf19 else} {\cf19 if} (msPassed < 2000)\par
00256                 sizeIndex = 2;\par
00257             {\cf19 else} {\cf19 if} (msPassed < 2500)\par
00258                 sizeIndex = 3;\par
00259         \}\par
00260         {\cf19 else} {\cf19 if} (msPassed < 5500 + randOffset * 3)\par
00261         \{\par
00262             theta = 180 + 10;\par
00263             sizeIndex = 3;\par
00264         \}\par
00265         {\cf19 else}\par
00266         \{\par
00267             theta = 180;\par
00268         \}\par
00269         scale = abs(randOffset / 300.f) + 0.5f;\par
00270         {\cf19 break};\par
00271     {\cf19 case} 5: {\cf20 // bottom right to slight upward charge}\par
00272         theta = 180 - abs(randOffset) / 300.f * 45;\par
00273         scale = abs(randOffset) / 150.f + 0.5f;\par
00274         sizeIndex = 2;\par
00275         {\cf19 break};\par
00276     {\cf19 case} 6: {\cf20 // alternate fish loop (from right)}\par
00277         {\cf19 if} (msPassed < 1000)\par
00278         \{\par
00279             theta = (-msPassed - 2000) / 4000.f * 360; {\cf20 // 180-270}\par
00280             scale = 2.f;\par
00281             sizeIndex = 2;\par
00282         \}\par
00283         {\cf19 else} {\cf19 if} (msPassed < 1700)\par
00284         \{\par
00285             theta = (-msPassed - 1700) / 1000.f * 360;\par
00286             sizeIndex = 1;\par
00287             scale = 1.6f;\par
00288         \}\par
00289         {\cf19 else}\par
00290         \{\par
00291             theta = 180 + 45;\par
00292             scale = 1.7f;\par
00293             sizeIndex = 2;\par
00294         \}\par
00295         {\cf19 break};\par
00296     {\cf19 case} 7: {\cf20 // 3 enemies from top right}\par
00297         theta = 210;\par
00298         scale = 1.3f;\par
00299         sizeIndex = 1;\par
00300         {\cf19 break};\par
00301     \}\par
00302 \par
00303     {\cf19 if} (theta != 0)\par
00304         transl = angleTranslate(theta, scale);\par
00305 \par
00306     sprite->move(transl.x, transl.y);\par
00307     {\cf19 return} transl;\par
00308 \}\par
00309 \par
00310 \par
00317 sf::Vector2f Enemy::angleTranslate({\cf18 float} angle, {\cf18 float} scale)\par
00318 \{\par
00319     sf::Vector2f ret;\par
00320     angle = angle * PI / 180.f;\par
00321     ret.x = cos(angle) * scale;\par
00322     ret.y = -sin(angle) * scale;\par
00323 \par
00324     {\cf19 return} ret;\par
00325 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Enemy/Enemy.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../Character.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Enemy}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Enemy} in the game. These use a recolored player bullet. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PI}\~ 3.1415f\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PI\:Enemy.h}
{\xe \v Enemy.h\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PI\~ 3.1415f}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b Enemy.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Enemy.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Enemy/Enemy.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../Character.h"}\par
00002 {\cf21 #define PI 3.1415f}\par
00003 {\cf21 #pragma once}\par
00004 \par
00005 \par
00009 {\cf17 class }Enemy : {\cf17 public} Character\par
00010 \{\par
00011 {\cf17 public}:\par
00012     Enemy(sf::Texture* texture, {\cf18 unsigned} {\cf18 int} {\cf18 id}, sf::Vector3f spawnZ,\par
00013           {\cf18 int} randOffset = 0);\par
00014     {\cf18 void} update(sf::RenderWindow&, {\cf18 float} gameSpeed) {\cf17 override};\par
00015     {\cf18 void} kill() {\cf17 override};\par
00016     {\cf18 bool} getTranslate2() \{ {\cf19 return} {\cf17 true}; \};\par
00017     {\cf18 unsigned} {\cf18 int} getSizeIndex();\par
00018     {\cf20 // Static so can be used from any context.}\par
00019     {\cf20 // Will spawn a wave of enemies relative to the player.}\par
00020     {\cf17 static} {\cf18 void} spawnWave(std::vector<Enemy*>&, sf::Texture*, {\cf18 int},\par
00021                           {\cf18 unsigned} {\cf18 int});\par
00022     {\cf18 bool} isDead() \{ {\cf19 return} dead; \};\par
00023 {\cf17 private}:\par
00024     {\cf20 // returns the velocity it has moved already}\par
00025     sf::Vector2f runAI();\par
00026     {\cf20 // angle -> x/z coords}\par
00027     sf::Vector2f angleTranslate({\cf18 float} angle, {\cf18 float} scale);\par
00028 \par
00029     sf::IntRect textures[2][4];\par
00030     sf::Clock alive;\par
00031     {\cf18 bool} dead = {\cf17 false};\par
00032     {\cf18 unsigned} {\cf18 int} sizeIndex = 0;\par
00033     {\cf18 unsigned} {\cf18 int} id;\par
00034     {\cf18 int} randOffset = 0;\par
00035 \par
00036     {\cf20 // bullets}\par
00037     {\cf18 bool} ableToFire = {\cf17 true};\par
00038     sf::Clock bulletCD;\par
00039 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Player/Player.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Player/Player.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Player/Player.cpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Player.h"}\par
{\f2 #include "Background/Background.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Player/Player.cpp}
{\xe \v C:/Zaxxon/src/Entity/Character/Player/Player.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Player.h"}\par
00002 {\cf21 #include "Background/Background.h"}\par
00003 \par
00004 \par
00010 Player::Player(sf::Texture* texture, {\cf18 unsigned} {\cf18 int} startPos) : Character(texture)\par
00011 \{\par
00012     sf::IntRect a = sf::IntRect(8, 13, 23, 23);\par
00013     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < 3; i++)\par
00014     \{\par
00015         {\cf19 for} ({\cf18 unsigned} {\cf18 int} j = 0; j < 4; j++)\par
00016         \{\par
00017             playerTextures[i][j] = a;\par
00018             a.left += 23;\par
00019         \}\par
00020     \}\par
00021 \par
00022     this->sprite->setTextureRect(playerTextures[0][0]);\par
00023     this->setPos(sf::Vector3f(0, 69, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(startPos) * -1.33333f));\par
00024     this->shadow.setTexture(*texture);\par
00025     this->shadow.setTextureRect(sf::IntRect(352, 18, 22, 13));\par
00026     this->shadow.setColor(sf::Color::Black);\par
00027     this->hitmarker.setTexture(*texture);\par
00028     this->hitmarker.setTextureRect(sf::IntRect(320, 84, 12, 11));\par
00029 \par
00030     {\cf20 // Prepare bullet sound}\par
00031     bulletBuffer.loadFromFile({\cf22 "res/sfx/08.wav"});\par
00032     bulletSound.setBuffer(bulletBuffer);\par
00033 \}\par
00034 \par
00035 \par
00042 {\cf18 void} Player::update(sf::RenderWindow& window, {\cf18 int} stage, {\cf18 float} gameSpeed)\par
00043 \{\par
00044     {\cf19 if} (!alive)\par
00045         {\cf19 return};\par
00046 \par
00047     {\cf20 // If alive after this point}\par
00048     {\cf20 // Update texture}\par
00049     {\cf18 unsigned} {\cf18 int} planeVertical = 0;\par
00050     _getSizeIndex(sizeIndex);\par
00051 \par
00052     {\cf20 // Keys}\par
00053     sf::Vector3f tempVelocity = getVelocity();\par
00054     {\cf17 constexpr} {\cf18 float} acceleration = 1.f / 5.f;\par
00055 \par
00056     {\cf19 if} (leftPressed() && getPos().x < xMax && tempVelocity.x < 1.f)\par
00057         tempVelocity.x += acceleration;\par
00058     {\cf19 else} {\cf19 if} (rightPressed() && getPos().x > xMin && tempVelocity.x > -1.f)\par
00059         tempVelocity.x -= acceleration;\par
00060     {\cf19 else} {\cf19 if} (tempVelocity.x < 0)\par
00061         tempVelocity.x += acceleration;\par
00062     {\cf19 else} {\cf19 if} (tempVelocity.x > 0)\par
00063         tempVelocity.x -= acceleration;\par
00064 \par
00065     {\cf19 if} (tempVelocity.x < acceleration && tempVelocity.x > -acceleration)\par
00066         tempVelocity.x = 0;\par
00067 \par
00068     {\cf19 if} (upPressed() && tempVelocity.y < 0.6f)\par
00069         tempVelocity.y += acceleration / 0.5f;\par
00070     {\cf19 else} {\cf19 if} (downPressed() && tempVelocity.y > -0.6f)\par
00071         tempVelocity.y -= acceleration / 0.5f;\par
00072     {\cf19 else} {\cf19 if} (tempVelocity.y < 0)\par
00073         tempVelocity.y += acceleration / 0.5f;\par
00074     {\cf19 else} {\cf19 if} (tempVelocity.y > 0)\par
00075         tempVelocity.y -= acceleration / 0.5f;\par
00076 \par
00077     {\cf20 // Set plane sprite var before we reset velocity for bounds}\par
00078     {\cf19 if} (tempVelocity.y == 0)\par
00079         planeVertical = 0;\par
00080     {\cf19 else} {\cf19 if} (tempVelocity.y < 0)\par
00081         planeVertical = 1;\par
00082     {\cf19 else} {\cf19 if} (tempVelocity.y > 0)\par
00083         planeVertical = 2;\par
00084 \par
00085     {\cf19 if} (getPos().y <= 69.6 && tempVelocity.y < 0)\par
00086         tempVelocity.y = 0;\par
00087     {\cf19 else} {\cf19 if} (getPos().y >= 139.4 && tempVelocity.y > 0)\par
00088         tempVelocity.y = 0;\par
00089 \par
00090     {\cf19 if} (stage != 1)\par
00091         sizeIndex = 0;\par
00092     sprite->setTextureRect(playerTextures[planeVertical][sizeIndex]);\par
00093 \par
00094     {\cf20 // Spawn bullets}\par
00095     {\cf19 if} (zPressed() && bulletCD.getElapsedTime().asMilliseconds() >\par
00096         BULLET_COOLDOWN / gameSpeed)\par
00097     \{\par
00098         bulletCD.restart();\par
00099 \par
00100         bullets.\par
00101             push_back({\cf17 new} CharacterBullet(spriteSheet, getPos(), sizeIndex));\par
00102 \par
00103         bulletSound.play();\par
00104     \}\par
00105 {\cf21 #ifndef NDEBUG}\par
00106     {\cf19 if} (sf::Keyboard::isKeyPressed(sf::Keyboard::K))\par
00107         std::cout << getPos().x << {\cf22 " "} << getPos().y << {\cf22 " "} << getPos().z <<\par
00108             {\cf22 "\\n"};\par
00109 {\cf21 #endif}\par
00110 \par
00111     {\cf19 if} (stage != 3)\par
00112     \{\par
00113         {\cf19 if} (stage != 1)\par
00114             tempVelocity.z = -1.3f; {\cf20 //for moving with background}\par
00115         {\cf19 else} {\cf20 // space moves 2/3 speed}\par
00116             tempVelocity.z = -1.3f * 0.66f;\par
00117     \}\par
00118     {\cf19 else}\par
00119         tempVelocity.z = 0;\par
00120 \par
00121     {\cf20 // Position updates}\par
00122     setVelocity(tempVelocity);\par
00123     shadow.setPosition(\par
00124         translateTo2d(sf::Vector3f(getPos().x - 5, 2 * 224 / 3, getPos().z)));\par
00125     hitmarker.setPosition(sprite->getPosition() + sf::Vector2f(40, -15));\par
00126 \par
00127     {\cf20 // Shadow before character}\par
00128     {\cf19 if} (stage != 1)\par
00129         window.draw(shadow);\par
00130     {\cf19 else} {\cf19 if} (hitmarkerTimer.getElapsedTime().asMilliseconds() < 150)\par
00131         window.draw(hitmarker);\par
00132 \par
00133     {\cf20 // if you stay above 80 for 3s and stage is initial then you get missile after you}\par
00134     {\cf19 if} (getPos().y > 80 || stage != 0)\par
00135         missileTimer.restart();\par
00136 \par
00137     {\cf20 // Drawing}\par
00138     Character::update(window, gameSpeed);\par
00139     {\cf20 // updating position using velocity, draw character}\par
00140     updateBullets(window, gameSpeed);\par
00141 \par
00142 {\cf21 #ifndef NDEBUG}\par
00143     debugText.setString(std::to_string({\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().x)) + {\cf22 " "} +\par
00144         std::to_string({\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().y)) + {\cf22 " "} + std::to_string(\par
00145             {\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().z))\par
00146     );\par
00147     debugText.setPosition(sprite->getPosition());\par
00148     window.draw(debugText);\par
00149 {\cf21 #endif }{\cf20 // !NDEBUG}\par
00150 \}\par
00151 \par
00152 \par
00156 {\cf18 void} Player::kill()\par
00157 \{\par
00158     alive = !alive;\par
00159 \}\par
00160 \par
00161 \par
00166 {\cf18 void} Player::resetPos({\cf18 int} zOffset)\par
00167 \{\par
00168     setPos(sf::Vector3f(getPos().x, getPos().y, zOffset * -1.33333f));\par
00169 \}\par
00170 \par
00171 \par
00176 {\cf18 bool} Player::isMissileable()\par
00177 \{\par
00178     {\cf19 return} missileTimer.getElapsedTime().asSeconds() > 5 && getPos().z < -300;\par
00179 \}\par
00180 \par
00181 \par
00186 {\cf18 bool} Player::isAlive()\par
00187 \{\par
00188     {\cf19 return} alive;\par
00189 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Character/Player/Player.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Player/Player.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Player/Player.h}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Audio.hpp>}\par
{\f2 #include "Entity/Character/Character.h"}\par
{\f2 #include "Entity/AbstractBullet/CharacterBullet/CharacterBullet.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Player}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The player character, also contains plane controls. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Character/Player/Player.h}
{\xe \v C:/Zaxxon/src/Entity/Character/Player/Player.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Audio.hpp>}\par
00003 {\cf21 #include "Entity/Character/Character.h"}\par
00004 {\cf21 #include "Entity/AbstractBullet/CharacterBullet/CharacterBullet.h"}\par
00005 \par
00006 \par
00010 {\cf17 class }Player : {\cf17 public} Character\par
00011 \{\par
00012 {\cf17 public}:\par
00013     Player(sf::Texture*, {\cf18 unsigned} {\cf18 int});\par
00014 \par
00015     {\cf18 void} update(sf::RenderWindow&, {\cf18 int}, {\cf18 float});\par
00016     {\cf18 void} kill() {\cf17 override};\par
00017     {\cf18 void} resetPos({\cf18 int} zOffset = 0);\par
00018     {\cf18 void} drawHitmarker() \{ hitmarkerTimer.restart(); \}\par
00019 \par
00020     {\cf18 bool} isAlive();\par
00021     {\cf18 bool} isMissileable();\par
00022 \par
00023     {\cf18 void} restartMissileTimer() \{ missileTimer.restart(); \};\par
00024 {\cf17 private}:\par
00025     {\cf17 const} {\cf18 int} BULLET_COOLDOWN = 200;\par
00026     {\cf18 bool} alive = {\cf17 true};\par
00027 \par
00028     sf::Sprite hitmarker;\par
00029     sf::Clock bulletCD, hitmarkerTimer, missileTimer;\par
00030     sf::IntRect playerTextures[3][4];\par
00031     sf::Sprite shadow;\par
00032     sf::SoundBuffer bulletBuffer;\par
00033     sf::Sound bulletSound;\par
00034 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Entity.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Entity.cpp}
{\xe \v C:/Zaxxon/src/Entity/Entity.cpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Entity.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Entity.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Entity.cpp}
{\xe \v C:/Zaxxon/src/Entity/Entity.cpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Entity.h"}\par
00002 \par
00003 \par
00007 Entity::Entity()\par
00008 \{\par
00009     this->sprite = {\cf17 new} sf::Sprite();\par
00010     this->spriteSheet = {\cf17 nullptr};\par
00011 \par
00012     debugFont.loadFromFile({\cf22 "C:\\\\Windows\\\\Fonts\\\\arial.ttf"});\par
00013     debugText.setFont(debugFont);\par
00014     debugText.setScale(sf::Vector2f(0.2f, 0.2f));\par
00015 \}\par
00016 \par
00017 \par
00021 Entity::~Entity()\par
00022 \{\par
00023     {\cf17 delete} sprite;\par
00024 \}\par
00025 \par
00026 \par
00030 {\cf18 void} Entity::kill(Animation::Anim animation)\par
00031 \{\par
00032     animations.run(sprite, animation);\par
00033 \}\par
00034 \par
00035 \par
00040 sf::Vector2f Entity::getSpritePos()\par
00041 \{\par
00042     {\cf19 return} sprite->getPosition();\par
00043 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Entity/Entity.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Entity.h}
{\xe \v C:/Zaxxon/src/Entity/Entity.h}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Animation/Animation.h"}\par
{\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <Util/Util.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Entity}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class for all entities in the game. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Entity.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Entity/Entity.h}
{\xe \v C:/Zaxxon/src/Entity/Entity.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include "Animation/Animation.h"}\par
00003 {\cf21 #include <SFML/Graphics.hpp>}\par
00004 {\cf21 #include <Util/Util.h>}\par
00005 \par
00006 \par
00010 {\cf17 class }Entity\par
00011 \{\par
00012 {\cf17 public}:\par
00013     Entity();\par
00014     {\cf17 virtual} ~Entity() = 0;\par
00015 \par
00016     {\cf17 virtual} {\cf18 void} kill(Animation::Anim animation = Animation::CHARACTER_DEATH);\par
00017     {\cf17 virtual} {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) = 0;\par
00018 \par
00019     {\cf18 int} getAnimationState() \{ {\cf19 return} animations.getState(); \};\par
00020     {\cf18 void} setPos(sf::Vector3f pos) \{ position = pos; \};\par
00021     sf::Vector3f getPos() \{ {\cf19 return} position; \};\par
00022     sf::FloatRect getBounds() \{ {\cf19 return} sprite->getGlobalBounds(); \};\par
00023     sf::Vector2f getSpritePos();\par
00024 {\cf17 protected}:\par
00025     sf::Texture* spriteSheet;\par
00026     sf::Sprite* sprite;\par
00027     Animation animations;\par
00028     {\cf18 bool} dead = {\cf17 false};\par
00029     sf::Text debugText;\par
00030     sf::Font debugFont;\par
00031 {\cf17 private}:\par
00032     sf::Vector3f position;\par
00033 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Game/Game.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Game/Game.cpp}
{\xe \v C:/Zaxxon/src/Game/Game.cpp}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Game.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr unsigned int {\b startPos} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b Background::Stage} {\b startStage} = {\b Background::INITIAL}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v startPos\:Game.cpp}
{\xe \v Game.cpp\:startPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr unsigned int startPos = 0{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b Game.cpp}.}\par
}
{\xe \v startStage\:Game.cpp}
{\xe \v Game.cpp\:startStage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr {\b Background::Stage} startStage = {\b Background::INITIAL}{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b Game.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Game/Game.cpp}
{\xe \v C:/Zaxxon/src/Game/Game.cpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Game.h"}\par
00002 \par
00003 {\cf17 constexpr} {\cf18 unsigned} {\cf18 int} startPos = 0;\par
00004 {\cf17 constexpr} Background::Stage startStage = Background::INITIAL;\par
00005 \par
00006 \par
00010 Game::Game()\par
00011     : window(sf::VideoMode(224, 256), {\cf22 "Zaxxon"}), gui(&spriteSheet)\par
00012 \{\par
00013     {\cf20 // Seed the randomization system for enemies and score system}\par
00014     srand({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(time({\cf17 nullptr})));\par
00015 \par
00016     {\cf20 // Loading our sprites}\par
00017     spriteSheet.loadFromFile({\cf22 "./res/spritesheet.png"});\par
00018     bossSheet.loadFromFile({\cf22 "./res/ZaxxonFull.png"});\par
00019 \par
00020     {\cf20 // Auto scaling, must be rounded to the nearest quarter to avoid visual bug}\par
00021     {\cf18 float} scale = (sf::VideoMode::getDesktopMode().height - 100) / 256.f;\par
00022     scale = round(scale * 4) / 4.f;\par
00023 \par
00024     window.setPosition(sf::Vector2i(\par
00025         {\cf17 static_cast<}{\cf18 int}{\cf17 >}(sf::VideoMode::getDesktopMode().width / 2.f - (224.f *\par
00026             scale) / 2.f), 0));\par
00027     {\cf20 //Set frame rate limit to smooth out}\par
00028     window.setFramerateLimit(60);\par
00029 \par
00030     {\cf20 // Resize window to scale, resize everything else with it using view}\par
00031     window.setSize(sf::Vector2u({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(224.f * scale),\par
00032                                 {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(256.f * scale)));\par
00033     mainView.reset(sf::FloatRect(0.f, 0.f, 224.f, 224.f));\par
00034     mainView.setViewport(sf::FloatRect(0.f, 0.f, 1.f, 224. / 256.));\par
00035     window.setView(mainView);\par
00036 \par
00037     {\cf20 // GUI must also be set at this time to overlay on the game screen}\par
00038     guiView.reset(sf::FloatRect(0.f, 0.f, 224.f, 256.f));\par
00039     guiView.setViewport(sf::FloatRect(0.f, 0.f, 1.f, 1.f));\par
00040 \par
00041     flightBuffer.loadFromFile({\cf22 "res/sfx/02.wav"});\par
00042     flightSound.setBuffer(flightBuffer);\par
00043     flightSound.setLoop({\cf17 true});\par
00044     flightSound.play();\par
00045 \par
00046     player = {\cf17 new} Player(&spriteSheet, startPos);\par
00047     mainView.move(sf::Vector2f(.8f * startPos, -.4f * startPos));\par
00048 \par
00049     {\cf20 // Ensure scores file exists}\par
00050     file.open({\cf22 "ZaxxonScores"});\par
00051     file.close();\par
00052 \par
00053     {\cf20 // background must be done after player.}\par
00054     pBackground = {\cf17 new} Background(startStage, mainView, &spriteSheet, obstacles,\par
00055                                  enemies, *player, startPos, walls, zapWalls);\par
00056 \par
00057     file.open({\cf22 "ZaxxonScores"}, std::ios::in);\par
00058     {\cf19 if} (file.is_open())\par
00059     \{\par
00060         {\cf19 for} ({\cf18 byte} i = 0; i < 6; i++)\par
00061         \{\par
00062             file >> currentScores[i];\par
00063 \par
00064             {\cf19 for} ({\cf18 byte} j = 0; j < 3; j++)\par
00065                 file >> currentNames[i][j];\par
00066         \}\par
00067 \par
00068         file.close();\par
00069     \}\par
00070 \par
00071     highScore = currentScores[0];\par
00072 \par
00073     gui.renderScores(window, currentScores, currentNames);\par
00074 \par
00075     deathSprite.setTexture(spriteSheet);\par
00076     deathSprite.setTextureRect(sf::IntRect(80, 156, 19, 19));\par
00077 \par
00078     boss = {\cf17 new} Boss(sf::Vector3f(-50, 139, -3800), player, &bossSheet,\par
00079                     &spriteSheet);\par
00080     missile = {\cf17 new} BossBullet(sf::Vector3f(0, 0, 1000), player, &spriteSheet);\par
00081     {\cf20 // spawn off-screen}\par
00082 \}\par
00083 \par
00084 \par
00088 Game::~Game()\par
00089 \{\par
00090     {\cf17 const} {\cf18 int} obstaclesSize = obstacles.size();\par
00091     {\cf19 for} ({\cf18 int} i = 0; i < obstaclesSize; i++)\par
00092         {\cf17 delete} obstacles[i];\par
00093 \par
00094     {\cf17 const} {\cf18 int} wallsSize = walls.size();\par
00095     {\cf19 for} ({\cf18 int} i = 0; i < wallsSize; i++)\par
00096         {\cf17 delete} walls[i];\par
00097 \par
00098     {\cf17 const} {\cf18 int} enemiesSize = enemies.size();\par
00099     {\cf19 for} ({\cf18 int} i = 0; i < enemiesSize; i++)\par
00100         {\cf17 delete} enemies[i];\par
00101 \par
00102     {\cf17 const} {\cf18 int} zapWallsSize = zapWalls.size();\par
00103     {\cf19 for} ({\cf18 int} i = 0; i < zapWallsSize; i++)\par
00104         {\cf17 delete} zapWalls[i];\par
00105 \par
00106     {\cf17 delete} player;\par
00107     {\cf17 delete} boss;\par
00108     {\cf17 delete} pBackground;\par
00109     {\cf17 delete} missile;\par
00110 \}\par
00111 \par
00112 \par
00116 {\cf18 void} Game::run() {\cf20 // if random errors later check that stack isnt full}\par
00117 \{\par
00118     Background& background = *pBackground;\par
00119 \par
00120     {\cf20 // Our game loop, will run forever until game is closed}\par
00121     {\cf19 while} (window.isOpen())\par
00122     \{\par
00123         sf::Event event;\par
00124         {\cf19 while} (window.pollEvent(event))\par
00125             {\cf19 if} (event.type == sf::Event::Closed)\par
00126                 window.close();\par
00127 \par
00128         {\cf20 // Each frame, clear the screen before drawing anything new}\par
00129         window.clear();\par
00130 \par
00131         {\cf20 // State 1 is actively playing the game}\par
00132         {\cf19 if} (gameState == 1)\par
00133         \{\par
00134             window.setView(mainView);\par
00135 \par
00136             {\cf20 // Things to do only when player is alive AKA these }\par
00137             {\cf20 // will be changed for player death}\par
00138             {\cf19 if} (player->isAlive())\par
00139             \{\par
00140                 {\cf20 // Fuel goes down every 0.2 seconds unless in space, }\par
00141                 {\cf20 // then it goes down every 1.6 seconds}\par
00142                 {\cf18 bool} inSpaceOffCD = background.isInSpace(\par
00143                         {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().z)) &&\par
00144                     (fuelClock.getElapsedTime().asSeconds() >= 1.6 / gameSpeed);\par
00145                 {\cf18 bool} outSpaceOffCD = !background.isInSpace(\par
00146                         {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().z)) &&\par
00147                     (fuelClock.getElapsedTime().asSeconds() >= 0.2 / gameSpeed);\par
00148 \par
00149                 {\cf20 // Collision checks}\par
00150                 doCollision(player);\par
00151 \par
00152                 {\cf20 // Fuel slowly runs out, player dies when fuel is empty.}\par
00153                 {\cf19 if} ((inSpaceOffCD || outSpaceOffCD) && background.getStage() !=\par
00154                     3)\par
00155                 \{\par
00156                     {\cf19 if} (fuel-- == 0)\par
00157                         playerDeath();\par
00158 \par
00159                     fuelClock.restart();\par
00160                 \}\par
00161                 {\cf20 // Move background}\par
00162                 background.update(window, mainView, gameSpeed, &spriteSheet,\par
00163                                   obstacles,\par
00164                                   enemies, *player, walls, zapWalls);\par
00165 \par
00166                 {\cf20 //Check if the boss has been defeated}\par
00167                 {\cf19 if} (background.getStage() == 3 && boss->isDestroyed())\par
00168                 \{\par
00169                     window.clear();\par
00170                     window.setView(guiView);\par
00171                     gui.renderWin(window);\par
00172                     gui.render(window, player->getPos().y, score, highScore,\par
00173                                fuel, lives);\par
00174                     window.display();\par
00175                     window.setView(mainView);\par
00176 \par
00177                     sf::Clock tempClock;\par
00178                     {\cf19 while} (tempClock.getElapsedTime().asSeconds() < 5);\par
00179 \par
00180                     fuel = 128, score += 1000;\par
00181 \par
00182                     {\cf20 //sets the background back to the initial stage}\par
00183                     background.setStage(Background::INITIAL);\par
00184                     background.resetPos(mainView, *player, 0);\par
00185                     background.generateObstacles(\par
00186                         Background::INITIAL, obstacles, &spriteSheet, walls,\par
00187                         zapWalls);\par
00188                     background.generateWaves(Background::INITIAL, enemies,\par
00189                                              &spriteSheet,\par
00190                                              {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().\par
00191                                                  z));\par
00192                     missile->setPos(sf::Vector3f(0, 0, 1000));\par
00193                 \}\par
00194             \}\par
00195             {\cf19 else} {\cf20 // Start the player death animation here}\par
00196             \{\par
00197                 background.update(window, mainView, 0, &spriteSheet, obstacles,\par
00198                                   enemies,\par
00199                                   *player, walls, zapWalls);\par
00200 \par
00201                 {\cf19 if} (deathClock.getElapsedTime().asSeconds() > 1)\par
00202                 {\cf20 // Make sure background is set back to default}\par
00203                     gameState = 2;\par
00204                 {\cf19 else}\par
00205                 \{\par
00206                     {\cf20 // Flash background red for start of player death animation}\par
00207                     {\cf19 if} (deathClock.getElapsedTime().asMilliseconds() / 200 % 2)\par
00208                     \{\par
00209                         window.setView(guiView);\par
00210                         pBackground->flashColor(window);\par
00211                         window.setView(mainView);\par
00212                     \}\par
00213                 \}\par
00214             \}\par
00215 \par
00216             {\cf20 // Draw obstacles that are behind the player}\par
00217             {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < obstacles.size(); i++)\par
00218                 {\cf19 if} (obstacles.at(i)->getPos().z < player->getPos().z)\par
00219                     obstacles.at(i)->update(\par
00220                         window, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().z), gameSpeed);\par
00221 \par
00222             {\cf20 // Draw walls that are behind the player}\par
00223             {\cf19 for} ({\cf18 byte} i = 0; i < walls.size(); i++) {\cf20 // For each wall...}\par
00224                 {\cf19 for} ({\cf18 byte} j = 0; j < walls.at(i)->getWallPositions().size() - 1;\par
00225                      j++) {\cf20 // Then for each section in that wall...}\par
00226                     {\cf19 if} (walls.at(i)->getWallPositions()[j].z < player->getPos().\par
00227                         z) {\cf20 // Then if that wall z is more than player z...}\par
00228                         walls.at(i)->drawWalls(window); {\cf20 // Draw it behind player}\par
00229 \par
00230             {\cf20 // Draw zap walls that are behind the player}\par
00231             {\cf19 for} ({\cf18 byte} i = 0; i < zapWalls.size(); i++)\par
00232                 {\cf19 if} (zapWalls.at(i)->getStartPosition().z < player->getPos().z)\par
00233                     zapWalls.at(i)->update(window, gameSpeed);\par
00234 \par
00235             {\cf20 // Draw enemies that are under the player}\par
00236             {\cf19 for} (Enemy* enemy : enemies)\par
00237                 {\cf19 if} (enemy->getPos().y > player->getPos().y)\par
00238                     enemy->update(window, gameSpeed);\par
00239 \par
00240             {\cf19 if} (pBackground->getStage() == 3)\par
00241                 boss->update(window, gameSpeed);\par
00242 \par
00243             {\cf19 if} (missile->isHit())\par
00244             \{\par
00245                 {\cf17 delete} missile;\par
00246                 missile = {\cf17 new} BossBullet(sf::Vector3f(0, 0, 1000), player,\par
00247                                          &spriteSheet); {\cf20 // spawn off screen}\par
00248             \}\par
00249             {\cf19 if} (player->isMissileable() && abs(\par
00250                 player->getPos().z - missile->getPos().z) > 1000)\par
00251                 missile->setPos(player->getPos() + sf::Vector3f(0, 40, -400));\par
00252             missile->update(window, gameSpeed);\par
00253 \par
00254 \par
00255             player->update(window, background.getStage(), gameSpeed);\par
00256 \par
00257             {\cf20 // Draw obstacles that are in front of the player}\par
00258             {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < obstacles.size(); i++)\par
00259                 {\cf19 if} (obstacles.at(i)->getPos().z >= player->getPos().z)\par
00260                     obstacles.at(i)->update(\par
00261                         window, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().z), gameSpeed);\par
00262 \par
00263             {\cf20 // Draw walls that are in front of the player}\par
00264             {\cf19 for} ({\cf18 byte} i = 0; i < walls.size(); i++) {\cf20 // For each wall...}\par
00265                 {\cf19 for} ({\cf18 byte} j = 0; j < walls.at(i)->getWallPositions().size() - 1;\par
00266                      j++) {\cf20 // Then for each section in that wall...}\par
00267                     {\cf19 if} (walls.at(i)->getWallPositions()[j].z >= player->getPos()\par
00268                         .z) {\cf20 // Then if that wall z is less than player z...}\par
00269                         walls.at(i)->drawWalls(window);\par
00270             {\cf20 // Draw it in front of player}\par
00271 \par
00272             {\cf20 // Draw zap walls that are in front of the player}\par
00273             {\cf19 for} ({\cf18 byte} i = 0; i < zapWalls.size(); i++)\par
00274                 {\cf19 if} (zapWalls.at(i)->getStartPosition().z >= player->getPos().z)\par
00275                     zapWalls.at(i)->update(window, gameSpeed);\par
00276 \par
00277             {\cf20 // Draw enemies that are above the player}\par
00278             {\cf19 for} (Enemy* enemy : enemies)\par
00279                 {\cf19 if} (enemy->getPos().y <= player->getPos().y)\par
00280                     enemy->update(window, gameSpeed);\par
00281 \par
00282             window.setView(guiView);\par
00283             gui.render(window, player->getPos().y, score, highScore, fuel,\par
00284                        lives);\par
00285         \}\par
00286         {\cf19 else} {\cf19 if} (gameState == 0) {\cf20 // State 0 is main menu screen}\par
00287         \{\par
00288             window.setView(guiView);\par
00289             gui.startRender(window, highScore);\par
00290             player->restartMissileTimer();\par
00291 \par
00292             {\cf19 if} (zPressed())\par
00293                 gameState = 1, score = 0;\par
00294         \}\par
00295         {\cf19 else} {\cf20 // dying}\par
00296         \{\par
00297             window.setView(mainView);\par
00298 \par
00299             {\cf18 float} time = deathClock.getElapsedTime().asSeconds();\par
00300 \par
00301             {\cf19 if} (deathClock.getElapsedTime().asSeconds() < 2)\par
00302             \{\par
00303                 {\cf20 // Change color of death explosion, 3 stages}\par
00304                 {\cf19 switch} (deathClock.getElapsedTime().asMilliseconds() / 100 % 3)\par
00305                 \{\par
00306                 {\cf19 case} 0:\par
00307                     deathSprite.setColor(sf::Color(255, 255, 255));\par
00308                     {\cf19 break};\par
00309                 {\cf19 case} 1:\par
00310                     deathSprite.setColor(sf::Color(222, 0, 0));\par
00311                     {\cf19 break};\par
00312                 {\cf19 case} 2:\par
00313                     deathSprite.setColor(sf::Color(0, 0, 0));\par
00314                     {\cf19 break};\par
00315                 \}\par
00316 \par
00317                 sf::Vector2f pos = player->getSpritePos();\par
00318 \par
00319                 {\cf20 // Set position for each death explosion based on current time}\par
00320                 {\cf19 for} ({\cf18 byte} i = 0; i < 12; i++)\par
00321                 \{\par
00322                     deathSprite.setPosition(pos);\par
00323 \par
00324                     {\cf19 if} (i < 3) {\cf20 // Above}\par
00325                         deathSprite.move(-1 * (1 + i % 3) * time * 5,\par
00326                                          -3 * (1 + i % 3) * time * 5);\par
00327                     {\cf19 else} {\cf19 if} (i < 6) {\cf20 // Left}\par
00328                         deathSprite.move(-3 * (1 + i % 3) * time * 5,\par
00329                                          1 * (1 + i % 3) * time * 5);\par
00330                     {\cf19 else} {\cf19 if} (i < 9) {\cf20 // Below}\par
00331                         deathSprite.move(1 * (1 + i % 3) * time * 5,\par
00332                                          3 * (1 + i % 3) * time * 5);\par
00333                     {\cf19 else} {\cf20 // Right}\par
00334                         deathSprite.move(3 * (1 + i % 3) * time * 5,\par
00335                                          -1 * (1 + i % 3) * time * 5);\par
00336 \par
00337                     window.draw(deathSprite);\par
00338                 \}\par
00339             \}\par
00340             {\cf19 else} {\cf19 if} (time >= 2 && lives > 0) {\cf20 // Reset pos backwards}\par
00341             \{\par
00342                 player->kill();\par
00343                 gameState = 1;\par
00344 \par
00345                 {\cf20 // Not perfect but works (moved from player::kill() during death update)}\par
00346                 player->setPos(sf::Vector3f(0, 69, player->getPos().z));\par
00347 \par
00348                 {\cf20 // You lose a life, this is not game over}\par
00349                 lives -= 1;\par
00350 \par
00351                 {\cf20 // Prepare for respawn}\par
00352                 fuel = 128;\par
00353                 {\cf19 if} (pBackground->getStage() == Background::BOSSFIGHT)\par
00354                     pBackground->setStage(Background::BOSS);\par
00355                 pBackground->resetPos(mainView, *player, 0);\par
00356                 pBackground->generateObstacles(pBackground->getStage(),\par
00357                                                obstacles, &spriteSheet, walls,\par
00358                                                zapWalls);\par
00359                 pBackground->generateWaves(pBackground->getStage(), enemies,\par
00360                                            &spriteSheet,\par
00361                                            {\cf17 static_cast<}{\cf18 int}{\cf17 >}(player->getPos().\par
00362                                                z));\par
00363                 missile->setPos(sf::Vector3f(0, 0, 1000));\par
00364                 player->restartMissileTimer();\par
00365             \}\par
00366             {\cf19 else} {\cf19 if} (time < 5) {\cf20 // Show game over text}\par
00367             \{\par
00368                 window.setView(guiView);\par
00369                 gui.renderEnd(window);\par
00370             \}\par
00371             {\cf19 else} {\cf19 if} (time < 25 && currentScores[5] < score) {\cf20 // Name entry}\par
00372             \{\par
00373                 {\cf20 // Controls for the zaxxon keyboard}\par
00374                 {\cf19 if} (upPressed() && activeCursor[0])\par
00375                 \{\par
00376                     selector -= 10;\par
00377 \par
00378                     {\cf19 if} (selector > 200)\par
00379                         selector -= 226;\par
00380 \par
00381                     activeCursor[0] = {\cf17 false};\par
00382                 \}\par
00383                 {\cf19 else} {\cf19 if} (!activeCursor[0] && !upPressed())\par
00384                     activeCursor[0] = {\cf17 true};\par
00385 \par
00386                 {\cf19 if} (downPressed() && activeCursor[1])\par
00387                 \{\par
00388                     selector += 10;\par
00389 \par
00390                     {\cf19 if} (selector > 29)\par
00391                         selector -= 30;\par
00392 \par
00393                     activeCursor[1] = {\cf17 false};\par
00394                 \}\par
00395                 {\cf19 else} {\cf19 if} (!activeCursor[1] && !downPressed())\par
00396                     activeCursor[1] = {\cf17 true};\par
00397 \par
00398                 {\cf19 if} (leftPressed() && activeCursor[2])\par
00399                 \{\par
00400                     selector--;\par
00401 \par
00402                     {\cf19 if} (selector > 200)\par
00403                         selector = 29;\par
00404 \par
00405                     activeCursor[2] = {\cf17 false};\par
00406                 \}\par
00407                 {\cf19 else} {\cf19 if} (!activeCursor[2] && !leftPressed())\par
00408                     activeCursor[2] = {\cf17 true};\par
00409 \par
00410                 {\cf19 if} (rightPressed() && activeCursor[3])\par
00411                 \{\par
00412                     selector++;\par
00413 \par
00414                     {\cf19 if} (selector > 29)\par
00415                         selector = 0;\par
00416 \par
00417                     activeCursor[3] = {\cf17 false};\par
00418                 \}\par
00419                 {\cf19 else} {\cf19 if} (!activeCursor[3] && !rightPressed())\par
00420                     activeCursor[3] = {\cf17 true};\par
00421 \par
00422                 {\cf19 if} (zPressed())\par
00423                 \{\par
00424                     {\cf19 if} (selector == 29) {\cf20 // END}\par
00425                         gameOver();\par
00426                     {\cf19 else} {\cf19 if} (selector == 28) {\cf20 // RUB}\par
00427                     \{\par
00428                         {\cf19 for} ({\cf18 byte} i = 0; i < 3; i++)\par
00429                             {\cf19 if} (name[2 - i] != {\cf23 '_'})\par
00430                                 name[2 - i] = {\cf23 '_'}, i = 3;\par
00431                     \}\par
00432                     {\cf19 else} {\cf20 // OTHERS}\par
00433                         {\cf19 for} ({\cf18 byte} i = 0; i < 3; i++)\par
00434                         \{\par
00435                             {\cf19 if} (name[i] == {\cf23 '_'})\par
00436                             \{\par
00437                                 {\cf19 if} (selector == 27)\par
00438                                     name[i] = {\cf23 ' '};\par
00439                                 {\cf19 else} {\cf19 if} (selector == 26)\par
00440                                     name[i] = 0;\par
00441                                 {\cf19 else}\par
00442                                     name[i] = {\cf23 'A'} + selector;\par
00443                                 i = 3;\par
00444                             \}\par
00445                         \}\par
00446                 \}\par
00447 \par
00448                 {\cf20 // Now render the keyboard and other name entry things}\par
00449                 window.setView(guiView);\par
00450                 gui.renderEnd(window, {\cf17 static_cast<}{\cf18 byte}{\cf17 >}(26 - time), selector,\par
00451                               name);\par
00452             \}\par
00453             {\cf19 else} {\cf20 // Now actually game over}\par
00454                 gameOver();\par
00455 \par
00456             window.setView(guiView);\par
00457             gui.render(window, player->getPos().y, score, highScore, fuel,\par
00458                        lives);\par
00459         \}\par
00460 \par
00461         {\cf20 // Display everything we just drew to the screen}\par
00462         window.display();\par
00463     \}\par
00464 \}\par
00465 \par
00466 \par
00471 {\cf18 void} Game::doCollision(Player* player)\par
00472 \{\par
00473     sf::Vector3f difference;\par
00474 \par
00475     {\cf20 //Turret Bullet Setup}\par
00476     std::vector<sf::Vector3f> bulletPos;\par
00477     {\cf18 unsigned} {\cf18 int} size;\par
00478 \par
00479     {\cf20 //Plane Bullet Setup}\par
00480     std::vector<sf::Vector3f> planeBulletPos;\par
00481     sf::Vector3f planePos;\par
00482     planePos = sf::Vector3f(player->getPos().x, player->getPos().y,\par
00483                             player->getPos().z);\par
00484 \par
00485     {\cf20 // Obstacle collisions}\par
00486     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < obstacles.size(); i++)\par
00487     \{\par
00488         Obstacle* obstacle = obstacles.at(i);\par
00489         {\cf19 if} (!obstacle->isPresent())\par
00490             {\cf19 continue};\par
00491 \par
00492         {\cf20 //Turret Bullets}\par
00493         bulletPos = (obstacle->getBulletLocations());\par
00494 \par
00495         {\cf19 for} ({\cf18 unsigned} {\cf18 int} bullets = 0; bullets < bulletPos.size(); bullets++)\par
00496         \{\par
00497             difference = sf::Vector3f(abs(bulletPos.at(bullets).x - planePos.x),\par
00498                                       abs(bulletPos.at(bullets).y - planePos.y),\par
00499                                       abs(bulletPos.at(\par
00500                                           bullets).z - planePos.z));\par
00501 \par
00502             {\cf19 if} (difference.x < 15 && difference.y < 15 && difference.z < 25)\par
00503             \{\par
00504                 playerDeath();\par
00505                 obstacle->bulletKill(bullets);\par
00506             \}\par
00507         \}\par
00508 \par
00509         bulletPos.clear();\par
00510         std::vector<CharacterBullet*>& bullets = player->getBullets();\par
00511         size = bullets.size();\par
00512 \par
00513         {\cf20 //Player Bullets Hitting Obstacles -- This only really works with translateTo2d }\par
00514         {\cf19 for} ({\cf18 unsigned} {\cf18 int} bulletIndex = 0; bulletIndex < size; bulletIndex++)\par
00515         \{\par
00516             difference = sf::Vector3f\par
00517             (abs(obstacle->getPos().x - bullets[bulletIndex]->getPos().x),\par
00518              abs(obstacle->getPos().y - bullets[bulletIndex]->getPos().y),\par
00519              abs(obstacle->getPos().z - bullets[bulletIndex]->getPos().z)\par
00520             );\par
00521 \par
00522             {\cf18 bool} hit = obstacleHit(obstacle->getType(), difference,\par
00523                                    obstacle->getBounds().intersects(\par
00524                                        bullets[bulletIndex]->getBounds())\par
00525             );\par
00526 \par
00527             {\cf19 if} (!hit)\par
00528                 {\cf19 continue};\par
00529             obstacle->kill();\par
00530             player->killBullet(bulletIndex);\par
00531             bulletIndex--;\par
00532             size--;\par
00533 \par
00534             {\cf20 //Scoring Swtich Statement}\par
00535             score += obstacle->getScore();\par
00536             {\cf19 switch} (obstacle->getType())\par
00537             \{\par
00538             {\cf19 case} 1:\par
00539                 fuel += 16;\par
00540                 {\cf19 break};\par
00541             {\cf19 case} 7:\par
00542                 fuel += 16;\par
00543                 {\cf19 break};\par
00544             \}\par
00545 \par
00546             {\cf19 if} (score > highScore)\par
00547                 highScore = score;\par
00548         \}\par
00549 \par
00550         {\cf20 //Player Running into Obstacles}\par
00551         difference = sf::Vector3f\par
00552         (abs(obstacle->getPos().x - planePos.x),\par
00553          abs(obstacle->getPos().y - planePos.y),\par
00554          abs(obstacle->getPos().z - planePos.z)\par
00555         );\par
00556         {\cf18 bool} hit = obstacleHit(obstacle->getType(), difference,\par
00557                                player->getBounds().intersects(\par
00558                                    obstacle->getBounds())\par
00559         );\par
00560 \par
00561         {\cf19 if} (hit)\par
00562             playerDeath();\par
00563     \}\par
00564 \par
00565     {\cf20 // Wall Collisions}\par
00566     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < walls.size(); i++)\par
00567     \{\par
00568         {\cf20 // If this wall is not visible, we don't need to check its collision}\par
00569         {\cf19 if} (!walls.at(i)->checkOnScreen())\par
00570             {\cf19 continue};\par
00571 \par
00572         {\cf20 // Now check the sections for each wall if they have been hit or not}\par
00573         {\cf19 for} ({\cf18 unsigned} {\cf18 int} j = 0; j < walls.at(i)->getWallPositions().size(); j\par
00574              ++)\par
00575         \{\par
00576             difference = sf::Vector3f\par
00577             (abs(walls.at(i)->getWallPositions().at(j).x - 20 - (planePos.x-10)),\par
00578                 abs(walls.at(i)->getWallPositions().at(j).y + 14 - planePos.y),\par
00579                 abs(walls.at(i)->getWallPositions().at(j).z - 10 - planePos.z));\par
00580 \par
00581             {\cf19 if} (difference.x < 25 && difference.y < 15 && difference.z < 10)\par
00582                 playerDeath();\par
00583         \}\par
00584 \par
00585         {\cf20 //Player runs into wall built into background}\par
00586         difference.z =\par
00587             abs(planePos.z - walls.at(i)->getWallPositions().at(0).z);\par
00588 \par
00589         {\cf20 //TO DO fix it so the x works and the y plus value is more accurate}\par
00590         {\cf19 if} (planePos.y > (walls.at(i)->getWallPositions().at(0).y + 10) &&\par
00591             difference.z < 20)\par
00592             playerDeath();\par
00593     \}\par
00594 \par
00595     {\cf20 //Zap Walls Collisions}\par
00596     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < zapWalls.size(); i++)\par
00597     \{\par
00598         {\cf20 // If this zap wall is not visible, we don't need to check its collision}\par
00599         {\cf19 if} (!zapWalls.at(i)->isOnScreen())\par
00600             {\cf19 continue};\par
00601 \par
00602         difference = sf::Vector3f\par
00603         (abs(zapWalls.at(i)->getStartPosition().x - planePos.x),\par
00604          abs(zapWalls.at(i)->getStartPosition().y - planePos.y),\par
00605          abs(zapWalls.at(i)->getStartPosition().z - planePos.z));\par
00606 \par
00607         {\cf19 if} (difference.y < 10 && difference.z < 10)\par
00608             playerDeath();\par
00609     \}\par
00610 \par
00611     {\cf20 // Bounds can be changed here if want to change later.}\par
00612     {\cf17 constexpr} {\cf18 float} hitboxSize = 4, bulletSize = 8;\par
00613     sf::FloatRect modBounds;\par
00614     modBounds = player->getBounds();\par
00615     modBounds.left += modBounds.width / 2.f - hitboxSize / 2.f;\par
00616     modBounds.top += modBounds.height / 2.f - hitboxSize / 2.f;\par
00617     modBounds.width = hitboxSize;\par
00618     modBounds.height = hitboxSize;\par
00619 \par
00620     {\cf20 // Enemy bullets collision with player}\par
00621     {\cf19 for} (Enemy* enemy : enemies)\par
00622     \{\par
00623         {\cf19 for} (CharacterBullet* bullet : enemy->getBullets())\par
00624         \{\par
00625             sf::FloatRect bulletBounds = bullet->getBounds();\par
00626             bulletBounds.left += bulletBounds.width / 2.f - bulletSize / 2.f;\par
00627             bulletBounds.top += bulletBounds.height / 2.f - bulletSize / 2.f;\par
00628             bulletBounds.width = bulletSize;\par
00629             bulletBounds.height = bulletSize;\par
00630 \par
00631             {\cf19 if} (bullet->getSizeIndex() == player->getSizeIndex() &&\par
00632                 bulletBounds.intersects(modBounds)\par
00633             )\par
00634                 playerDeath();\par
00635         \}\par
00636     \}\par
00637 \par
00638     BossBullet* bossMissile = boss->getMissile();\par
00639     {\cf18 int} bulletNum = 0;\par
00640 \par
00641     {\cf20 // Player bullets collision with enemy}\par
00642     {\cf19 for} (CharacterBullet* bullet : player->getBullets())\par
00643     \{\par
00644         sf::FloatRect bulletBounds = bullet->getBounds();\par
00645         bulletBounds.left += bulletBounds.width / 2.f - bulletSize / 2.f;\par
00646         bulletBounds.top += bulletBounds.height / 2.f - bulletSize / 2.f;\par
00647         bulletBounds.width = bulletSize;\par
00648         bulletBounds.height = bulletSize;\par
00649 \par
00650         {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < enemies.size(); i++)\par
00651         \{\par
00652             Enemy* enemy = enemies[i];\par
00653             {\cf19 if} (enemy->isDead())\par
00654                 {\cf19 continue};\par
00655             modBounds = enemy->getBounds();\par
00656             modBounds.left += modBounds.width / 2 - hitboxSize / 2;\par
00657             modBounds.top += modBounds.height / 2 - hitboxSize / 2;\par
00658             modBounds.width = hitboxSize;\par
00659             modBounds.height = hitboxSize;\par
00660 \par
00661             {\cf19 if} (bullet->getSizeIndex() == enemy->getSizeIndex() &&\par
00662                 bulletBounds.intersects(modBounds)\par
00663             )\par
00664             \{\par
00665                 player->drawHitmarker();\par
00666                 bullet->kill();\par
00667                 enemy->kill();\par
00668             \}\par
00669         \}\par
00670 \par
00671         {\cf20 //Player Bullets hitting walls}\par
00672         {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < walls.size(); i++)\par
00673         \{\par
00674             {\cf19 if} (!walls.at(i)->checkOnScreen())\par
00675                 {\cf19 continue};\par
00676 \par
00677             {\cf19 for} ({\cf18 unsigned} {\cf18 int} j = 0; j < walls.at(i)->getWallPositions().size();\par
00678                  j++)\par
00679             \{\par
00680                 difference = sf::Vector3f\par
00681                 (abs(walls.at(i)->getWallPositions().at(j).x - 20 - bullet->getPos().x),\par
00682                     abs(walls.at(i)->getWallPositions().at(j).y + 15 - bullet->getPos().y),\par
00683                     abs(walls.at(i)->getWallPositions().at(j).z - 10 - bullet->getPos().z));\par
00684 \par
00685                 {\cf19 if} (difference.x < 25 && difference.y < 20 && difference.z < 20)\par
00686                     bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00687             \}\par
00688 \par
00689             {\cf20 //Player Bullets hit walls build into background}\par
00690             difference.z = abs(\par
00691                 bullet->getPos().z - walls.at(i)->getWallPositions().at(0).z);\par
00692 \par
00693             {\cf19 if} (planePos.y > (walls.at(i)->getWallPositions().at(0).y + 10) &&\par
00694                 difference.z < 10)\par
00695                 bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00696         \}\par
00697 \par
00698         {\cf20 //Player Bullets hitting zap walls}\par
00699         {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < zapWalls.size(); i++)\par
00700         \{\par
00701             {\cf19 if} (!zapWalls.at(i)->isOnScreen())\par
00702                 {\cf19 continue};\par
00703 \par
00704             difference = sf::Vector3f\par
00705             (abs(zapWalls.at(i)->getStartPosition().x - bullet->getPos().x),\par
00706              abs(zapWalls.at(i)->getStartPosition().y - bullet->getPos().y),\par
00707              abs(zapWalls.at(i)->getStartPosition().z - bullet->getPos().z));\par
00708 \par
00709             {\cf19 if} (difference.y < 15 && difference.z < 15)\par
00710                 bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00711         \}\par
00712 \par
00713         {\cf20 //Player Bullets Hitting Boss}\par
00714         {\cf19 if} (abs(bullet->getPos().z - boss->getPos().z) <= 10 &&\par
00715             abs(bullet->getPos().x - boss->getPos().x) < 40 &&\par
00716             abs(bullet->getPos().y - boss->getPos().y) <= 40)\par
00717         \{\par
00718             bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00719 \par
00720             {\cf19 if} (abs(bullet->getPos().z - boss->getPos().z) <= 10 &&\par
00721                 abs(bullet->getPos().x - boss->getPos().x + 33) <= 10 &&\par
00722                 abs(bullet->getPos().y - boss->getPos().y + 21) <= 10)\par
00723                 boss->hit();\par
00724         \}\par
00725 \par
00726         {\cf20 //Player bullets hitting boss missile}\par
00727         {\cf19 if} (boss->missileCreated() && abs(\par
00728                 bullet->getPos().z - bossMissile->getPos().z) <= 10 &&\par
00729             abs(bullet->getPos().x - bossMissile->getPos().x - 50) < 20 &&\par
00730             abs(bullet->getPos().y - bossMissile->getPos().y) <= 20)\par
00731         \{\par
00732             bossMissile->damage(1);\par
00733             bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00734         \}\par
00735 \par
00736         {\cf20 //Player bullets hitting boss missile}\par
00737         {\cf19 if} (abs(bullet->getPos().z - missile->getPos().z) <= 10 &&\par
00738             abs(bullet->getPos().x - missile->getPos().x - 50) < 20 &&\par
00739             abs(bullet->getPos().y - missile->getPos().y) <= 20)\par
00740         \{\par
00741             missile->damage(1);\par
00742             bullet->kill(CharacterBullet::BulletDeathType::WallDeath);\par
00743         \}\par
00744 \par
00745         bulletNum++;\par
00746     \}\par
00747 \par
00748     {\cf20 // boss missile}\par
00749     {\cf19 if} (boss->missileCreated() && abs(bossMissile->getPos().z - planePos.z) <=\par
00750         5)\par
00751     \{\par
00752         playerDeath();\par
00753         bossMissile->collide();\par
00754     \}\par
00755 \par
00756     {\cf20 // game missile}\par
00757     {\cf19 if} (abs(missile->getPos().z - planePos.z) <= 5)\par
00758     \{\par
00759         playerDeath();\par
00760         missile->collide();\par
00761     \}\par
00762 \}\par
00763 \par
00764 \par
00772 {\cf18 bool} Game::obstacleHit(Obstacle::ObstacleType type, sf::Vector3f difference,\par
00773                        {\cf18 bool} intersect2d)\par
00774 \{\par
00775     {\cf18 bool} hit = {\cf17 true};\par
00776     sf::Vector3f obstaclePos, playerPos;\par
00777 \par
00778     {\cf19 switch} (type)\par
00779     \{\par
00780     {\cf19 case} Obstacle::GAS_CAN:\par
00781     {\cf19 case} Obstacle::SATELLITE:\par
00782     {\cf19 case} Obstacle::PLANE:\par
00783     {\cf19 case} Obstacle::SPACE_FUEL:\par
00784     {\cf19 case} Obstacle::GREEN_CANNON_RIGHT:\par
00785         hit = difference.x < 20 && difference.y < 15 && difference.z < 25;\par
00786         {\cf19 break};\par
00787     {\cf19 case} Obstacle::GREY_CANNON:\par
00788     {\cf19 case} Obstacle::GREEN_CANNON:\par
00789         hit = difference.x < 20 && difference.y < 5 && difference.z < 25;\par
00790         {\cf19 break};\par
00791     {\cf19 case} Obstacle::MISSILE_UP:\par
00792         hit = intersect2d && difference.y < 8 && difference.z < 8;\par
00793         {\cf19 break};\par
00794     \}\par
00795 \par
00796     {\cf19 return} hit;\par
00797 \}\par
00798 \par
00799 \par
00803 {\cf18 void} Game::playerDeath()\par
00804 \{\par
00805     player->kill();\par
00806     {\cf20 // deathClock is used for player death anzimation, so start clock here.}\par
00807     deathClock.restart();\par
00808 \}\par
00809 \par
00810 \par
00814 {\cf18 void} Game::gameOver()\par
00815 \{\par
00816     gameState = 0;\par
00817     lives = 3;\par
00818     selector = 0;\par
00819     pBackground->setStage(Background::INITIAL);\par
00820 \par
00821     {\cf20 // Replace bottom score?}\par
00822     {\cf19 if} (currentScores[5] < score)\par
00823     \{\par
00824         {\cf20 // When replacing and sorting, we need to keep the score and}\par
00825         {\cf20 // initials for that score together for the leaderboard.}\par
00826         currentScores[5] = score;\par
00827         currentNames[5] = name;\par
00828 \par
00829         {\cf20 // Now sort it}\par
00830         {\cf19 for} ({\cf18 int} i = 0; i < 5; i++)\par
00831         \{\par
00832             {\cf19 if} (currentScores[5 - i] > currentScores[4 - i])\par
00833             \{\par
00834                 {\cf17 const} {\cf18 int} tempScore = currentScores[5 - i];\par
00835                 currentScores[5 - i] = currentScores[4 - i];\par
00836                 currentScores[4 - i] = tempScore;\par
00837 \par
00838                 {\cf17 const} std::string tempName = currentNames[5 - i];\par
00839                 currentNames[5 - i] = currentNames[4 - i];\par
00840                 currentNames[4 - i] = tempName;\par
00841             \}\par
00842         \}\par
00843     \}\par
00844 \par
00845     file.open({\cf22 "ZaxxonScores"}, std::ios::out);\par
00846     {\cf19 for} ({\cf18 byte} i = 0; i < 6; i++)\par
00847     \{\par
00848         file << currentScores[i] << {\cf23 ' '};\par
00849 \par
00850         {\cf19 for} ({\cf18 byte} j = 0; j < 3; j++)\par
00851             file << currentNames[i][j];\par
00852 \par
00853         file << {\cf23 ' '};\par
00854     \}\par
00855     file.close();\par
00856 \par
00857     {\cf20 // Refresh leaderboard}\par
00858     gui.renderScores(window, currentScores, currentNames);\par
00859 \par
00860     {\cf20 // Refresh name}\par
00861     name[0] = {\cf23 '_'}, name[1] = {\cf23 '_'}, name[2] = {\cf23 '_'};\par
00862 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Game/Game.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Game/Game.h}
{\xe \v C:/Zaxxon/src/Game/Game.h}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <chrono>}\par
{\f2 #include <fstream>}\par
{\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <SFML/Audio.hpp>}\par
{\f2 #include "Obstacle/Obstacle.h"}\par
{\f2 #include "Entity/Entity.h"}\par
{\f2 #include "Entity/Character/Player/Player.h"}\par
{\f2 #include "Entity/Character/Enemy/Enemy.h"}\par
{\f2 #include "GUI/GUI.h"}\par
{\f2 #include "Wall/Wall.h"}\par
{\f2 #include "Background/Background.h"}\par
{\f2 #include "Entity/Boss/Boss.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Game}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main game and all related classes eventually end up being used here. {\b Game} loop is in here and is the 'heart' of the whole program. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b byte} = unsigned char\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v byte\:Game.h}
{\xe \v Game.h\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b byte} = unsigned char}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b Game.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Game/Game.h}
{\xe \v C:/Zaxxon/src/Game/Game.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <vector>}\par
00003 {\cf21 #include <chrono>}\par
00004 {\cf21 #include <fstream>}\par
00005 {\cf21 #include <SFML/Graphics.hpp>}\par
00006 {\cf21 #include <SFML/Audio.hpp>}\par
00007 {\cf21 #include "Obstacle/Obstacle.h"}\par
00008 {\cf21 #include "Entity/Entity.h"}\par
00009 {\cf21 #include "Entity/Character/Player/Player.h"}\par
00010 {\cf21 #include "Entity/Character/Enemy/Enemy.h"}\par
00011 {\cf21 #include "GUI/GUI.h"}\par
00012 {\cf21 #include "Wall/Wall.h"}\par
00013 {\cf21 #include "Background/Background.h"}\par
00014 {\cf21 #include "Entity/Boss/Boss.h"}\par
00015 \par
00016 {\cf20 // Clearer than using unsigned char often}\par
00017 {\cf17 using }byte = {\cf18 unsigned} char;\par
00018 \par
00019 \par
00024 {\cf17 class }Game\par
00025 \{\par
00026 {\cf17 public}:\par
00027     Game();\par
00028     ~Game();\par
00029     {\cf18 void} run();\par
00030 {\cf17 private}:\par
00031     sf::Texture spriteSheet, bossSheet;\par
00032     Background* pBackground;\par
00033     sf::RenderWindow window;\par
00034     GUI gui;\par
00035 \par
00036     Player* player;\par
00037     std::vector<Enemy*> enemies;\par
00038     std::vector<Obstacle*> obstacles;\par
00039     std::vector<Wall*> walls;\par
00040     std::vector<ZapWall*> zapWalls;\par
00041     Boss* boss = {\cf17 nullptr};\par
00042     BossBullet* missile = {\cf17 nullptr};\par
00043 \par
00044     {\cf18 byte} fuel = 128;\par
00045     {\cf18 byte} completions = 0;\par
00046     {\cf18 byte} lives = 2;\par
00047     {\cf18 int} score = 0;\par
00048     {\cf18 int} highScore = 0;\par
00049     {\cf18 float} gameSpeed = 1.0;\par
00050     {\cf18 byte} gameState = 0;\par
00051     {\cf18 int} currentScores[6] = \{0, 0, 0, 0, 0, 0\};\par
00052     std::string currentNames[6] = \{{\cf22 "   "}, {\cf22 "   "}, {\cf22 "   "}, {\cf22 "   "}, {\cf22 "   "}, {\cf22 "   "}\};\par
00053     {\cf18 char} name[3] = \{{\cf23 '_'}, {\cf23 '_'}, {\cf23 '_'}\};\par
00054     {\cf18 bool} activeCursor[4] = \{{\cf17 true}, {\cf17 true}, {\cf17 true}, {\cf17 true}\};\par
00055     {\cf18 byte} selector = 0;\par
00056     std::fstream file;\par
00057     {\cf18 unsigned} {\cf18 int} fps = 0;\par
00058     {\cf18 double} deltaTime = 0;\par
00059     std::chrono::steady_clock::time_point lastTime =\par
00060                                               std::chrono::high_resolution_clock::now()\par
00061                                           , currentTime;\par
00062 \par
00063     sf::View mainView;\par
00064     sf::View guiView;\par
00065     sf::SoundBuffer flightBuffer;\par
00066     sf::Sound flightSound;\par
00067     sf::Clock fuelClock;\par
00068     sf::Clock deathClock;\par
00069     sf::Sprite deathSprite;\par
00070 \par
00071     {\cf18 void} doCollision(Player*);\par
00072     {\cf18 bool} obstacleHit(Obstacle::ObstacleType type, sf::Vector3f difference,\par
00073                      {\cf18 bool} intersect2d);\par
00074     {\cf18 void} playerDeath();\par
00075     {\cf18 void} gameOver();\par
00076 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/GUI.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/GUI.cpp}
{\xe \v C:/Zaxxon/src/GUI/GUI.cpp}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GUI.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/GUI.cpp}
{\xe \v C:/Zaxxon/src/GUI/GUI.cpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "GUI.h"}\par
00002 \par
00003 \par
00008 GUI::GUI(sf::Texture* spritesheet)\par
00009 \{\par
00010     this->spritesheet = spritesheet;\par
00011     heightMeterBg.setFillColor(sf::Color::Black);\par
00012     heightMeterBg.setPosition(0, 73);\par
00013     heightMeterBg.setSize(sf::Vector2f(8, 89));\par
00014     hudElements.push_back(&heightMeterBg);\par
00015 \par
00016     heightH = ZaxxonText::get(spritesheet, {\cf23 'H'});\par
00017     heightH.setPosition(0, 73 - 8);\par
00018     heightH.setColor(sf::Color(222, 0, 0)); {\cf20 // red right of chars}\par
00019     hudElements.push_back(&heightH);\par
00020 \par
00021     heightL = ZaxxonText::get(spritesheet, {\cf23 'L'});\par
00022     heightL.setPosition(0, 162);\par
00023     heightL.setColor(sf::Color(0, 222, 0)); {\cf20 // green right of chars}\par
00024     hudElements.push_back(&heightL);\par
00025 \par
00026     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00027     \{\par
00028         HMSection& section = heightMeterSections[i];\par
00029         section.setTexture(*spritesheet);\par
00030 \par
00031         {\cf19 if} (i == 0)\par
00032             section.setType(HMSection::TOP);\par
00033         {\cf19 else} {\cf19 if} (i == 9)\par
00034             section.setType(HMSection::BOTTOM);\par
00035         {\cf19 else} {\cf19 if} (i % 2 == 1) {\cf20 // odd number}\par
00036             section.setType(HMSection::OPEN);\par
00037         {\cf19 else}\par
00038             section.setType(HMSection::LINE);\par
00039 \par
00040         section.setPosition(0, heightH.getPosition().y + 16 + 8 * i);\par
00041         hudElements.push_back(&section);\par
00042     \}\par
00043 \par
00044     {\cf20 // Copyright text}\par
00045     ZaxxonText::string(spritesheet, {\cf22 "\\x1D\\x1ESEGA1982"}, copyright);\par
00046 \par
00047     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00048     \{\par
00049         copyright[i].setColor(sf::Color(222, 222, 247));\par
00050 \par
00051         {\cf18 byte} start = 124;\par
00052         {\cf19 if} (i >= 6)\par
00053             start += 16;\par
00054         {\cf19 else} {\cf19 if} (i >= 2)\par
00055             start += 8;\par
00056 \par
00057         copyright[i].setPosition(start + 8.f * i, 248.f);\par
00058     \}\par
00059 \par
00060     {\cf20 // Top score text}\par
00061     ZaxxonText::string(spritesheet, {\cf22 "TOP000000"}, topScore);\par
00062 \par
00063     {\cf19 for} ({\cf18 byte} i = 0; i < 9; i++)\par
00064     \{\par
00065         topScore[i].setColor(sf::Color(0, 222, 247));\par
00066 \par
00067         {\cf18 byte} start = 0;\par
00068         {\cf19 if} (i > 2)\par
00069             start += 8;\par
00070 \par
00071         topScore[i].setPosition(start + 8.f * i, 8.f);\par
00072     \}\par
00073 \par
00074     {\cf20 // 1up score text}\par
00075     ZaxxonText::string(spritesheet, {\cf22 "1UP000000"}, curScore);\par
00076 \par
00077     {\cf19 for} ({\cf18 byte} i = 0; i < 9; i++)\par
00078     \{\par
00079         curScore[i].setColor(sf::Color(222, 222, 247));\par
00080 \par
00081         {\cf18 byte} start = 0;\par
00082         {\cf19 if} (i > 2)\par
00083             start += 8;\par
00084 \par
00085         curScore[i].setPosition(start + 8.f * i, 24.f);\par
00086     \}\par
00087 \par
00088     {\cf20 // Fuel text}\par
00089     ZaxxonText::string(spritesheet, {\cf22 "FUELEF"}, fuelText);\par
00090 \par
00091     {\cf19 for} ({\cf18 byte} i = 0; i < 6; i++)\par
00092     \{\par
00093         {\cf19 if} (i < 4)\par
00094         \{\par
00095             fuelText[i].setColor(sf::Color(0, 222, 0));\par
00096             fuelText[i].setPosition(12.f + i * 8.f, 240.f);\par
00097         \}\par
00098         {\cf19 else}\par
00099         \{\par
00100             fuelText[i].setColor(sf::Color(222, 0, 0));\par
00101             fuelText[i].setPosition(52.f + (i - 4.f) * 136.f, 240.f);\par
00102         \}\par
00103     \}\par
00104 \par
00105     {\cf20 // Enemy plane text}\par
00106     ZaxxonText::string(spritesheet, {\cf22 "ENEMYPLANE"}, enemyText);\par
00107 \par
00108     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00109     \{\par
00110         enemyText[i].setColor(sf::Color(222, 222, 247));\par
00111         {\cf20 // These use integer for the equation, do not 'float' it}\par
00112         {\cf20 // edit: explicitedly casted it.}\par
00113         enemyText[i].setPosition(sf::Vector2f(\par
00114             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(176 + i % 5 * 8),\par
00115             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(200 + i / 5 * 8)));\par
00116     \}\par
00117 \par
00118     {\cf20 // Fuel bar sprites}\par
00119     {\cf19 for} ({\cf18 byte} i = 0; i < 16; i++)\par
00120     \{\par
00121         fuelBar[i].setTexture(*spritesheet);\par
00122         fuelBar[i].setTextureRect(sf::IntRect(328, 296, 8, 8));\par
00123         fuelBar[i].setPosition(60.f + i * 8.f, 240.f);\par
00124     \}\par
00125 \par
00126     {\cf20 // Lives bar sprites}\par
00127     livesBar.setTexture(*spritesheet);\par
00128     livesBar.setTextureRect(sf::IntRect(344, 288, 16, 16));\par
00129     livesBar.setPosition(12.f, 224.f);\par
00130 \par
00131     {\cf20 // Enemies left}\par
00132     ZaxxonText::string(spritesheet, {\cf22 "X\\u000a20"}, enemyLeft);\par
00133     enemyLeft[0].setTextureRect(sf::IntRect(368, 296, 8, 8));\par
00134 \par
00135     {\cf19 for} ({\cf18 byte} i = 0; i < 4; i++)\par
00136         enemyLeft[i].setPosition(176.f + i * 8.f, 216.f);\par
00137 \par
00138     {\cf20 // Start screen, push player button}\par
00139     ZaxxonText::string(spritesheet, {\cf22 "PUSH1OR2PLAYERBUTTON"}, pushPlayerText);\par
00140     {\cf19 for} ({\cf18 byte} i = 0; i < 20; i++)\par
00141     \{\par
00142         {\cf18 byte} start = 8;\par
00143 \par
00144         {\cf19 if} (i >= 4)\par
00145             start += 8;\par
00146         {\cf19 if} (i >= 5)\par
00147             start += 8;\par
00148         {\cf19 if} (i >= 7)\par
00149             start += 8;\par
00150         {\cf19 if} (i >= 8)\par
00151             start += 8;\par
00152         {\cf19 if} (i >= 14)\par
00153             start += 8;\par
00154 \par
00155         pushPlayerText[i].setColor(sf::Color(0, 222, 247));\par
00156         pushPlayerText[i].setPosition(sf::Vector2f(start + 8.f * i, 92.f));\par
00157     \}\par
00158 \par
00159     {\cf20 // Start screen, high score text}\par
00160     ZaxxonText::string(spritesheet, {\cf22 "HIGHSCORES"}, highScoresText);\par
00161     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00162     \{\par
00163         {\cf18 byte} start = 72;\par
00164 \par
00165         {\cf19 if} (i >= 4)\par
00166             start += 8;\par
00167 \par
00168         highScoresText[i].setColor(sf::Color(222, 222, 0));\par
00169         highScoresText[i].setPosition(sf::Vector2f(\par
00170             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(120)));\par
00171     \}\par
00172 \par
00173     {\cf20 // Game over text}\par
00174     ZaxxonText::string(spritesheet, {\cf22 "GAMEOVER"}, gameOver);\par
00175     {\cf19 for} ({\cf18 byte} i = 0; i < 8; i++)\par
00176     \{\par
00177         {\cf18 byte} start = 60;\par
00178 \par
00179         {\cf19 if} (i >= 4)\par
00180             start += 16;\par
00181 \par
00182         gameOver[i].setColor(sf::Color(222, 222, 222));\par
00183         gameOver[i].setPosition(sf::Vector2f({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8),\par
00184                                              {\cf17 static_cast<}{\cf18 float}{\cf17 >}(115)));\par
00185     \}\par
00186 \par
00187     {\cf20 // High score entry}\par
00188     ZaxxonText::string(spritesheet, {\cf22 "HIGHSCOREENTRY"}, scoreEntry);\par
00189     {\cf19 for} ({\cf18 byte} i = 0; i < 14; i++)\par
00190     \{\par
00191         {\cf18 byte} start = 32;\par
00192 \par
00193         {\cf19 if} (i >= 4)\par
00194             start += 8;\par
00195         {\cf19 if} (i >= 9)\par
00196             start += 8;\par
00197 \par
00198         scoreEntry[i].setColor(sf::Color(222, 0, 0));\par
00199         scoreEntry[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8),\par
00200                                   {\cf17 static_cast<}{\cf18 float}{\cf17 >}(75));\par
00201     \}\par
00202 \par
00203     {\cf20 // Initials :}\par
00204     ZaxxonText::string(spritesheet, {\cf22 "INITIALS\\u0004"}, initialsText);\par
00205     {\cf19 for} ({\cf18 byte} i = 0; i < 9; i++)\par
00206     \{\par
00207         {\cf18 byte} start = 32;\par
00208 \par
00209         {\cf19 if} (i == 8)\par
00210             start += 8;\par
00211 \par
00212         initialsText[i].setColor(sf::Color(0, 222, 247));\par
00213         initialsText[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8),\par
00214                                     {\cf17 static_cast<}{\cf18 float}{\cf17 >}(95));\par
00215     \}\par
00216 \par
00217     {\cf20 // Entry time}\par
00218     ZaxxonText::string(spritesheet, {\cf22 "ENTRYTIME\\u000620\\u0007"}, entryTime);\par
00219     {\cf19 for} ({\cf18 byte} i = 0; i < 13; i++)\par
00220     \{\par
00221         {\cf18 byte} start = 32;\par
00222         {\cf19 if} (i >= 5)\par
00223             start += 8;\par
00224         {\cf19 if} (i >= 9)\par
00225             start += 16;\par
00226 \par
00227         entryTime[i].setColor(sf::Color(222, 222, 0));\par
00228         entryTime[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8),\par
00229                                  {\cf17 static_cast<}{\cf18 float}{\cf17 >}(115));\par
00230     \}\par
00231 \par
00232     {\cf20 // Name entry keyboard}\par
00233     {\cf19 for} ({\cf18 byte} i = 0; i < 28; i++)\par
00234     \{\par
00235         {\cf19 if} (i < 26)\par
00236             keyboard[i] = ZaxxonText::get(spritesheet, {\cf23 'A'} + i);\par
00237         {\cf19 else}\par
00238             keyboard[i] = ZaxxonText::get(spritesheet, 0 + i - 26);\par
00239 \par
00240         keyboard[i].setColor(sf::Color(0, 222, 0));\par
00241         keyboard[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(32 + i % 10 * 16),\par
00242                                 {\cf17 static_cast<}{\cf18 float}{\cf17 >}(135 + i / 10 * 16));\par
00243     \}\par
00244 \par
00245     {\cf20 // Keyboard RUB & END}\par
00246     keyboard[28].setTexture(*spritesheet);\par
00247     keyboard[28].setTextureRect(sf::IntRect(200, 248, 29, 8));\par
00248     keyboard[28].setColor(sf::Color(0, 222, 0));\par
00249     keyboard[28].setPosition(keyboard[27].getPosition().x + 13,\par
00250                              keyboard[27].getPosition().y);\par
00251 \par
00252     {\cf20 // Cursor selector for the keyboard}\par
00253     cursor.setTexture(*spritesheet);\par
00254     cursor.setTextureRect(sf::IntRect(316, 264, 16, 16));\par
00255 \par
00256     {\cf20 // End screen}\par
00257     ZaxxonText::string(spritesheet,\par
00258                        {\cf22 "CONGRATULATIONS\\u000cYOUGETBONUS1000PTS\\u0001GOOD\\u000c"},\par
00259                        endScreen);\par
00260     {\cf19 for} ({\cf18 byte} i = 0; i < 40; i++)\par
00261     \{\par
00262         {\cf20 // Different positions/colors for each 3 lines of text}\par
00263         {\cf19 if} (i < 16)\par
00264         \{\par
00265             {\cf18 short} start = 40;\par
00266 \par
00267             {\cf19 if} (i == 15)\par
00268                 start += 8;\par
00269 \par
00270             endScreen[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i * 8),\par
00271                                      {\cf17 static_cast<}{\cf18 float}{\cf17 >}(80));\par
00272             endScreen[i].setColor(sf::Color(0, 222, 247));\par
00273         \}\par
00274         {\cf19 else} {\cf19 if} (i < 35)\par
00275         \{\par
00276             {\cf18 short} start = 16;\par
00277 \par
00278             {\cf19 if} (i > 18)\par
00279                 start += 8;\par
00280             {\cf19 if} (i > 21)\par
00281                 start += 8;\par
00282             {\cf19 if} (i > 26)\par
00283                 start += 8;\par
00284             {\cf19 if} (i > 30)\par
00285                 start += 8;\par
00286 \par
00287             endScreen[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + (i - 16) * 8),\par
00288                                      {\cf17 static_cast<}{\cf18 float}{\cf17 >}(100));\par
00289             endScreen[i].setColor(sf::Color(222, 222, 0));\par
00290         \}\par
00291         {\cf19 else}\par
00292         \{\par
00293             {\cf18 short} start = 88;\par
00294 \par
00295             {\cf19 if} (i == 39)\par
00296                 start += 8;\par
00297 \par
00298             endScreen[i].setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + (i - 35) * 8),\par
00299                                      {\cf17 static_cast<}{\cf18 float}{\cf17 >}(120));\par
00300             endScreen[i].setColor(sf::Color(222, 222, 222));\par
00301         \}\par
00302     \}\par
00303 \}\par
00304 \par
00305 \par
00315 {\cf18 void} GUI::render(sf::RenderWindow& window, {\cf18 float} playerY, {\cf18 int} score,\par
00316                  {\cf18 int} highScore, {\cf18 byte} fuel, {\cf18 byte} lives)\par
00317 \{\par
00318     window.draw(heightMeterBg);\par
00319     {\cf20 /* 69top 135bottom 66 in between, multiply by below number to get 68}\par
00320 {\cf20     should be 8 sections each for line/open and 2 each for top/bottom so}\par
00321 {\cf20     yDiff should be 68 max (68 from 8*8 + 4) also round to make sure correct}\par
00322 {\cf20     */}\par
00323     {\cf18 int} yDiff = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(round((playerY - 69.f) * 0.95774647887f));\par
00324     {\cf19 if} (yDiff < 0)\par
00325         yDiff = 0;\par
00326 \par
00327     {\cf20 // -4 to make 64}\par
00328     {\cf18 int} selection = (yDiff - 2) / 8;\par
00329     {\cf19 if} (selection < 0)\par
00330         selection = 0;\par
00331 \par
00332     {\cf18 bool} changingBelow = {\cf17 false}, changingAbove = {\cf17 false};\par
00333     {\cf18 byte} last = 7, localYDiff = (yDiff - 2) % 8;\par
00334     {\cf19 if} (localYDiff == 6)\par
00335         localYDiff = 7;\par
00336 \par
00337     {\cf19 if} (yDiff <= 66 && yDiff >= 2)\par
00338     \{\par
00339         HMSection& activeSection = heightMeterSections[selection];\par
00340 \par
00341         activeSection.progress(localYDiff);\par
00342 \par
00343         {\cf19 if} (localYDiff >= 5)\par
00344         \{\par
00345             heightMeterSections[selection + 1].progress(localYDiff - 7);\par
00346             changingBelow = {\cf17 true};\par
00347         \}\par
00348     \}\par
00349     {\cf19 else} {\cf19 if} (yDiff < 8)\par
00350     \{\par
00351         {\cf20 // top}\par
00352         heightMeterSections[0].progress(12 + localYDiff);\par
00353     \}\par
00354     {\cf19 else} {\cf19 if} (yDiff > 64)\par
00355     \{\par
00356         {\cf20 // bottom}\par
00357     \}\par
00358 \par
00359     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00360     \{\par
00361         HMSection& section = heightMeterSections[i];\par
00362         {\cf19 if} (i < selection)\par
00363         \{\par
00364             {\cf19 if} (i != selection - 1 || !changingAbove)\par
00365                 section.empty();\par
00366         \}\par
00367         {\cf19 else} {\cf19 if} (i > selection)\par
00368         \{\par
00369             {\cf19 if} (i != selection + 1 || !changingBelow)\par
00370                 section.fill();\par
00371         \}\par
00372 \par
00373         window.draw(section);\par
00374     \}\par
00375     window.draw(heightH);\par
00376     window.draw(heightL);\par
00377 \par
00378     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00379     \{\par
00380         window.draw(copyright[i]);\par
00381         window.draw(enemyText[i]);\par
00382     \}\par
00383 \par
00384     {\cf20 // Update score}\par
00385     {\cf19 for} ({\cf18 byte} i = 0; i < 6; i++)\par
00386     \{\par
00387         std::string scoreStr = std::to_string(score);\par
00388         std::string highStr = std::to_string(highScore);\par
00389 \par
00390         {\cf19 while} (scoreStr.length() < 6)\par
00391             scoreStr = {\cf23 '0'} + scoreStr;\par
00392         {\cf19 while} (highStr.length() < 6)\par
00393             highStr = {\cf23 '0'} + highStr;\par
00394 \par
00395         curScore[8 - i] = ZaxxonText::get(spritesheet, scoreStr.at(5 - i));\par
00396         curScore[8 - i].setPosition(72.f - 8.f * i, 24.f);\par
00397         curScore[8 - i].setColor(sf::Color(222, 222, 247));\par
00398 \par
00399         topScore[8 - i] = ZaxxonText::get(spritesheet, highStr.at(5 - i));\par
00400         topScore[8 - i].setPosition(72.f - 8.f * i, 8.f);\par
00401         topScore[8 - i].setColor(sf::Color(0, 222, 247));\par
00402     \}\par
00403 \par
00404     {\cf19 for} ({\cf18 byte} i = 0; i < 9; i++)\par
00405     \{\par
00406         window.draw(topScore[i]);\par
00407 \par
00408         {\cf19 if} (i >= 3)\par
00409             window.draw(curScore[i]);\par
00410     \}\par
00411 \par
00412     {\cf20 // 1up score will flash}\par
00413     {\cf19 if} (scoreClock.getElapsedTime().asSeconds() > 0.4)\par
00414     \{\par
00415         {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00416             window.draw(curScore[i]);\par
00417 \par
00418         {\cf19 if} (scoreClock.getElapsedTime().asSeconds() > 0.8)\par
00419             scoreClock.restart();\par
00420     \}\par
00421 \par
00422     {\cf19 for} ({\cf18 byte} i = 0; i < 6; i++)\par
00423         window.draw(fuelText[i]);\par
00424 \par
00425     {\cf20 // Update fuel bar}\par
00426     {\cf19 for} ({\cf18 byte} i = 0; i < 16; i++)\par
00427     \{\par
00428         sf::IntRect status(328, 296, 8, 8);\par
00429         {\cf19 if} (fuel - i * 8 < 8)\par
00430             {\cf19 if} (fuel - i * 8 > 0)\par
00431                 status.left = 328 - (8 - (fuel - i * 8) % 8) * 16;\par
00432             {\cf19 else}\par
00433                 status.left = 176, status.top = 272;\par
00434 \par
00435         fuelBar[i].setTextureRect(status);\par
00436         window.draw(fuelBar[i]);\par
00437     \}\par
00438 \par
00439     {\cf19 for} ({\cf18 byte} i = 0; i < lives; i++)\par
00440     \{\par
00441         livesBar.setPosition(12.f + i * 16.f, 224.f);\par
00442         window.draw(livesBar);\par
00443     \}\par
00444 \par
00445     {\cf19 for} ({\cf18 byte} i = 0; i < 4; i++)\par
00446         window.draw(enemyLeft[i]);\par
00447 \}\par
00448 \par
00449 \par
00456 {\cf18 void} GUI::startRender(sf::RenderWindow& window, {\cf18 int} highScore)\par
00457 \{\par
00458     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00459         window.draw(copyright[i]);\par
00460 \par
00461     {\cf19 for} ({\cf18 byte} i = 0; i < 9; i++)\par
00462     \{\par
00463         window.draw(topScore[i]);\par
00464         window.draw(curScore[i]);\par
00465     \}\par
00466 \par
00467     {\cf19 for} ({\cf18 byte} i = 0; i < 20; i++)\par
00468         window.draw(pushPlayerText[i]);\par
00469 \par
00470     {\cf19 for} ({\cf18 byte} i = 0; i < 42; i++)\par
00471         window.draw(highScores[i]);\par
00472 \par
00473     {\cf19 for} ({\cf18 byte} i = 0; i < 10; i++)\par
00474         window.draw(highScoresText[i]);\par
00475 \par
00476     {\cf19 for} ({\cf18 byte} i = 0; i < 18; i++)\par
00477         window.draw(highScoresNames[i]);\par
00478 \}\par
00479 \par
00480 \par
00486 {\cf18 void} GUI::renderScores(sf::RenderWindow& window, {\cf18 int} scores[],\par
00487                        std::string names[])\par
00488 \{\par
00489     {\cf20 // The score values}\par
00490     {\cf19 for} ({\cf18 byte} i = 0; i < 42; i++)\par
00491     \{\par
00492         {\cf19 if} (i % 7 == 0)\par
00493             highScores[i] = ZaxxonText::get(spritesheet, {\cf23 '1'} + i / 7);\par
00494         {\cf19 else}\par
00495         \{\par
00496             std::string scoreStr = std::to_string(scores[i / 7]);\par
00497 \par
00498             {\cf19 while} (scoreStr.length() < 6)\par
00499                 scoreStr = {\cf23 '0'} + scoreStr;\par
00500 \par
00501             highScores[i] = ZaxxonText::get(spritesheet,\par
00502                                             scoreStr[0 + (i % 7) - 1]);\par
00503         \}\par
00504 \par
00505         highScores[i].setColor(sf::Color(0, 222, 0));\par
00506 \par
00507         {\cf18 int} start = 4;\par
00508         {\cf19 if} (i % 7)\par
00509             start += 8;\par
00510         {\cf19 if} (i >= 21)\par
00511             start += 120;\par
00512 \par
00513         {\cf18 int} layer = 140;\par
00514         layer += 12 * (i % 21 / 7);\par
00515         highScores[i].setPosition(sf::Vector2f(\par
00516             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i % 7 * 8), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(layer)));\par
00517     \}\par
00518 \par
00519     {\cf20 // The names for each score}\par
00520     {\cf19 for} ({\cf18 byte} i = 0; i < 18; i++)\par
00521     \{\par
00522         {\cf20 // We use _ for spaces in names}\par
00523         {\cf19 if} (names[i / 3][i % 3] != {\cf23 '_'})\par
00524             highScoresNames[i] = ZaxxonText::get(\par
00525                 spritesheet, names[i / 3][i % 3]);\par
00526 \par
00527         highScoresNames[i].setColor(sf::Color(0, 222, 0));\par
00528 \par
00529         {\cf18 int} start = 76;\par
00530         {\cf19 if} (i >= 9)\par
00531             start += 120;\par
00532 \par
00533         {\cf18 int} layer = 140;\par
00534         layer += 12 * (i % 9 / 3);\par
00535         highScoresNames[i].setPosition(sf::Vector2f(\par
00536             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(start + i % 3 * 8), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(layer)));\par
00537     \}\par
00538 \}\par
00539 \par
00540 \par
00547 {\cf18 void} GUI::renderEnd(sf::RenderWindow& window, {\cf18 byte} timeLeft, {\cf18 byte} selector,\par
00548                     {\cf17 const} {\cf18 char} name[3])\par
00549 \{\par
00550     {\cf19 if} (timeLeft == 255)\par
00551     \{\par
00552         {\cf19 for} ({\cf18 byte} i = 0; i < 8; i++)\par
00553             window.draw(gameOver[i]);\par
00554 \par
00555         {\cf19 return};\par
00556     \}\par
00557 \par
00558     {\cf19 for} ({\cf18 byte} i = 0; i < 14; i++)\par
00559         window.draw(scoreEntry[i]);\par
00560 \par
00561     {\cf19 for} ({\cf18 byte} i = 9; i < 12; i++)\par
00562     \{\par
00563         {\cf19 if} (name[i] != {\cf23 '_'} && name[i] != {\cf23 ' '})\par
00564             initialsText[i] = ZaxxonText::get(spritesheet, name[i - 9]);\par
00565         initialsText[i].setColor(sf::Color(0, 222, 247));\par
00566         initialsText[i].setPosition(sf::Vector2f(\par
00567             {\cf17 static_cast<}{\cf18 float}{\cf17 >}(120 + (i - 9) * 16), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(95)));\par
00568     \}\par
00569 \par
00570     {\cf19 for} ({\cf18 byte} i = 0; i < 12; i++)\par
00571         window.draw(initialsText[i]);\par
00572 \par
00573     entryTime[10] = ZaxxonText::get(spritesheet, {\cf23 '0'} + timeLeft / 10);\par
00574     entryTime[10].setPosition(136, 115);\par
00575     entryTime[10].setColor(sf::Color(222, 222, 0));\par
00576     entryTime[11] = ZaxxonText::get(spritesheet, {\cf23 '0'} + timeLeft % 10);\par
00577     entryTime[11].setPosition(144, 115);\par
00578     entryTime[11].setColor(sf::Color(222, 222, 0));\par
00579 \par
00580     {\cf19 for} ({\cf18 byte} i = 0; i < 13; i++)\par
00581         window.draw(entryTime[i]);\par
00582 \par
00583     {\cf20 // Draw cursor before keyboard}\par
00584     cursor.setPosition({\cf17 static_cast<}{\cf18 float}{\cf17 >}(28 + selector % 10 * 16),\par
00585                        {\cf17 static_cast<}{\cf18 float}{\cf17 >}(131 + selector / 10 * 16));\par
00586     window.draw(cursor);\par
00587 \par
00588     {\cf19 for} ({\cf18 byte} i = 0; i < 30; i++)\par
00589         window.draw(keyboard[i]);\par
00590 \}\par
00591 \par
00592 \par
00597 {\cf18 void} GUI::renderWin(sf::RenderWindow& window)\par
00598 \{\par
00599     {\cf19 for} ({\cf18 byte} i = 0; i < 40; i++)\par
00600         window.draw(endScreen[i]);\par
00601 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/GUI.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/GUI.h}
{\xe \v C:/Zaxxon/src/GUI/GUI.h}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include "ZaxxonText/ZaxxonText.h"}\par
{\f2 #include "HMSection/HMSection.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GUI}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all {\b GUI} used in the game, including all text. These are simple but can take a lot of space due to how much there is. Different GUIs are split into different render functions. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b byte} = unsigned char\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v byte\:GUI.h}
{\xe \v GUI.h\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b byte} = unsigned char}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b GUI.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/GUI.h}
{\xe \v C:/Zaxxon/src/GUI/GUI.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <vector>}\par
00003 {\cf21 #include "ZaxxonText/ZaxxonText.h"}\par
00004 {\cf21 #include "HMSection/HMSection.h"}\par
00005 \par
00006 {\cf17 using }byte = {\cf18 unsigned} char;\par
00007 \par
00008 \par
00014 {\cf17 class }GUI\par
00015 \{\par
00016 {\cf17 public}:\par
00017     GUI(sf::Texture*);\par
00018     {\cf18 void} render(sf::RenderWindow&, {\cf18 float}, {\cf18 int}, {\cf18 int}, {\cf18 byte}, {\cf18 byte});\par
00019     {\cf18 void} startRender(sf::RenderWindow&, {\cf18 int});\par
00020     {\cf18 void} renderScores(sf::RenderWindow&, {\cf18 int} [], std::string []);\par
00021     {\cf18 void} renderEnd(sf::RenderWindow&, {\cf18 byte} = 255, {\cf18 byte} = 0,\par
00022                    {\cf17 const} {\cf18 char} [3] = {\cf22 "   "});\par
00023     {\cf18 void} renderWin(sf::RenderWindow&);\par
00024 {\cf17 private}:\par
00025     sf::Texture* spritesheet;\par
00026 \par
00027     sf::RectangleShape heightMeterBg;\par
00028     HMSection heightMeterSections[10];\par
00029     sf::Sprite heightH;\par
00030     sf::Sprite heightL;\par
00031     std::vector<sf::Transformable*> hudElements;\par
00032 \par
00033     sf::Sprite copyright[10];\par
00034     sf::Sprite topScore[9];\par
00035     sf::Sprite curScore[9];\par
00036     sf::Sprite fuelText[6];\par
00037     sf::Sprite enemyText[10];\par
00038 \par
00039     sf::Sprite fuelBar[16];\par
00040     sf::Sprite livesBar;\par
00041     sf::Sprite enemyLeft[4];\par
00042 \par
00043     sf::Sprite pushPlayerText[25];\par
00044 \par
00045     sf::Clock scoreClock;\par
00046 \par
00047     sf::Sprite highScores[42];\par
00048     sf::Sprite highScoresText[10];\par
00049     sf::Sprite highScoresNames[18];\par
00050 \par
00051     sf::Sprite gameOver[8];\par
00052     sf::Sprite scoreEntry[14];\par
00053     sf::Sprite initialsText[12];\par
00054     sf::Sprite entryTime[13];\par
00055     sf::Sprite keyboard[30];\par
00056     sf::Sprite cursor;\par
00057 \par
00058     sf::Sprite endScreen[40];\par
00059 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/HMSection/HMSection.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/HMSection/HMSection.cpp}
{\xe \v C:/Zaxxon/src/GUI/HMSection/HMSection.cpp}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "HMSection.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HMSection.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/HMSection/HMSection.cpp}
{\xe \v C:/Zaxxon/src/GUI/HMSection/HMSection.cpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "HMSection.h"}\par
00002 \par
00003 \par
00008 {\cf18 void} HMSection::setSection({\cf18 int} sect)\par
00009 \{\par
00010     {\cf20 // 25 sections 8 - 207 x}\par
00011     section = sect % 25;\par
00012 \par
00013     {\cf20 // Never be negative check}\par
00014     {\cf19 if} (section < 0)\par
00015         section = 0;\par
00016 \par
00017     this->setTextureRect(sf::IntRect(8 + section * 8, 296, 8, 8));\par
00018 \}\par
00019 \par
00020 \par
00025 {\cf18 void} HMSection::setType(Type type)\par
00026 \{\par
00027     this->type = type;\par
00028     {\cf19 switch} (this->type)\par
00029     \{\par
00030     {\cf19 case} LINE:\par
00031         setSection(8);\par
00032         {\cf19 break};\par
00033     {\cf19 case} OPEN:\par
00034         setSection(3);\par
00035         {\cf19 break};\par
00036     {\cf19 case} TOP:\par
00037         setSection(6);\par
00038         {\cf19 break};\par
00039     {\cf19 case} BOTTOM:\par
00040         setSection(4);\par
00041         {\cf19 break};\par
00042     \}\par
00043 \}\par
00044 \par
00045 \par
00050 {\cf18 int} HMSection::getSection()\par
00051 \{\par
00052     {\cf19 return} section;\par
00053 \}\par
00054 \par
00055 \par
00060 {\cf18 void} HMSection::progress({\cf18 int} stage)\par
00061 \{\par
00062     {\cf18 int} change;\par
00063 \par
00064     {\cf19 if} (stage >= 0)\par
00065     \{\par
00066         {\cf19 switch} (this->type)\par
00067         \{\par
00068         {\cf19 case} TOP:\par
00069         {\cf19 case} LINE:\par
00070             change = 16 - stage;\par
00071             setSection(change);\par
00072         {\cf20 // full 9-16 to 5-8: blank to full so 8-5 then 16-9: full to blank}\par
00073             {\cf19 break};\par
00074         {\cf19 case} OPEN:\par
00075             change = 24 - stage;\par
00076             setSection(change);\par
00077         {\cf20 // 17-24 to 0-3: blank to full so 3-0 then 24-17: full to blank}\par
00078             {\cf19 break};\par
00079         {\cf19 case} BOTTOM:\par
00080             {\cf19 break};\par
00081         \}\par
00082     \}\par
00083     {\cf19 else}\par
00084     \{\par
00085         {\cf19 switch} (this->type)\par
00086         \{\par
00087         {\cf19 case} TOP:\par
00088         {\cf19 case} LINE:\par
00089             change = 9 + stage;\par
00090             setSection(change);\par
00091             {\cf19 break};\par
00092         {\cf19 case} OPEN:\par
00093             change = 4 + stage;\par
00094             setSection(change);\par
00095             {\cf19 break};\par
00096         {\cf19 case} BOTTOM:\par
00097             {\cf19 break};\par
00098         \}\par
00099     \}\par
00100 \}\par
00101 \par
00102 \par
00106 {\cf18 void} HMSection::fill()\par
00107 \{\par
00108     {\cf19 switch} (this->type)\par
00109     \{\par
00110     {\cf19 case} LINE:\par
00111         setSection(8);\par
00112         {\cf19 break};\par
00113     {\cf19 case} OPEN:\par
00114         setSection(3);\par
00115         {\cf19 break};\par
00116     {\cf19 case} TOP:\par
00117         setSection(5);\par
00118     {\cf19 case} BOTTOM:\par
00119         setSection(4);\par
00120         {\cf19 break};\par
00121     \}\par
00122 \}\par
00123 \par
00124 \par
00128 {\cf18 void} HMSection::empty()\par
00129 \{\par
00130     {\cf19 switch} (this->type)\par
00131     \{\par
00132     {\cf19 case} TOP:\par
00133     {\cf19 case} LINE:\par
00134         setSection(9);\par
00135         {\cf19 break};\par
00136     {\cf19 case} OPEN:\par
00137         setSection(17);\par
00138         {\cf19 break};\par
00139     {\cf19 case} BOTTOM:\par
00140         setSection(4);\par
00141         {\cf19 break};\par
00142     \}\par
00143 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/HMSection/HMSection.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/HMSection/HMSection.h}
{\xe \v C:/Zaxxon/src/GUI/HMSection/HMSection.h}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HMSection}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The height meter and related methods. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HMSection.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/HMSection/HMSection.h}
{\xe \v C:/Zaxxon/src/GUI/HMSection/HMSection.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <SFML/Graphics.hpp>}\par
00002 {\cf21 #pragma once}\par
00003 \par
00004 \par
00008 {\cf17 class }HMSection : {\cf17 public} sf::Sprite\par
00009 \{\par
00010 {\cf17 public}:\par
00011     {\cf17 enum} Type\par
00012     \{\par
00013         LINE,\par
00014         OPEN,\par
00015         TOP,\par
00016         BOTTOM\par
00017     \};\par
00018 \par
00019     {\cf18 void} progress({\cf18 int});\par
00020     {\cf18 void} setSection({\cf18 int});\par
00021     {\cf18 void} setType(Type);\par
00022     {\cf18 void} fill();\par
00023     {\cf18 void} empty();\par
00024 \par
00025     {\cf18 int} getSection();\par
00026 {\cf17 private}:\par
00027     {\cf18 int} section = 0;\par
00028     {\cf18 int} type = 0;\par
00029 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.cpp}
{\xe \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.cpp}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ZaxxonText.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZaxxonText.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.cpp}
{\xe \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.cpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ZaxxonText.h"}\par
00002 \par
00003 \par
00011 sf::Sprite ZaxxonText::get(sf::Texture* spritemap, {\cf18 char} in)\par
00012 \{\par
00013     {\cf20 // chars: 65-90 inclusive}\par
00014     {\cf20 // nums: 48-57 inclusive}\par
00015     {\cf20 // other: 0-31 inclusive}\par
00016     in = toupper(in);\par
00017     {\cf18 int} column = 0, row = 0;\par
00018     {\cf19 if} (in >= 65 && in <= 90)\par
00019         column = in - {\cf23 'A'};\par
00020     {\cf19 else} {\cf19 if} (in >= 48 && in <= 57)\par
00021         column = in - {\cf23 '0'} + 26;\par
00022     {\cf19 else}\par
00023         column = in - 1, row = 16;\par
00024 \par
00025     sf::Sprite retVal;\par
00026 \par
00027     retVal.setTexture(*spritemap);\par
00028     retVal.setTextureRect(sf::IntRect(8 + 8 * column, 232 + row, 8, 8));\par
00029 \par
00030     {\cf19 return} retVal;\par
00031 \}\par
00032 \par
00033 \par
00041 {\cf18 void} ZaxxonText::string(sf::Texture* spritemap, std::string in, sf::Sprite* arr)\par
00042 \{\par
00043     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < in.size(); i++)\par
00044         arr[i] = get(spritemap, in[i]);\par
00045 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.h}
{\xe \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ZaxxonText}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to grab text sprites from spritesheet given char or string. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZaxxonText.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.h}
{\xe \v C:/Zaxxon/src/GUI/ZaxxonText/ZaxxonText.h}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <SFML/Graphics.hpp>}\par
00002 {\cf21 #pragma once}\par
00003 \par
00004 \par
00008 {\cf17 class }ZaxxonText\par
00009 \{\par
00010 {\cf17 public}:\par
00011     {\cf17 static} sf::Sprite get(sf::Texture*, {\cf18 char});\par
00012     {\cf17 static} {\cf18 void} string(sf::Texture*, std::string, sf::Sprite*);\par
00013 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Obstacle/Obstacle.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Obstacle/Obstacle.cpp}
{\xe \v C:/Zaxxon/src/Obstacle/Obstacle.cpp}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Obstacle.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Obstacle.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Obstacle/Obstacle.cpp}
{\xe \v C:/Zaxxon/src/Obstacle/Obstacle.cpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Obstacle.h"}\par
00002 \par
00003 \par
00011 Obstacle::Obstacle(sf::Vector3f pos, sf::Texture* tex, {\cf18 int} delay,\par
00012                    {\cf18 int} dir) : Entity()\par
00013 \{\par
00014     total = (rand() % 250) + 75;\par
00015     this->scoreIndicator = rand() % 3 + 1;\par
00016     this->type = {\cf17 static_cast<}ObstacleType{\cf17 >}(dir + 3);\par
00017 \par
00018     setPos(pos);\par
00019     turret = {\cf17 true};\par
00020     direction = dir;\par
00021 \par
00022     spriteSheet = tex;\par
00023 \par
00024     {\cf19 switch} (dir)\par
00025     \{\par
00026     {\cf20 //grey turrets}\par
00027     {\cf19 case} 0:\par
00028         sprite->setTexture((*spriteSheet));\par
00029         sprite->setTextureRect(sf::IntRect(8, 112, 29, 19));\par
00030 \par
00031         sprite->setPosition(translateTo2d(pos));\par
00032         sprite->setOrigin(sprite->getGlobalBounds().width / 2,\par
00033             sprite->getGlobalBounds().height / 2);\par
00034         {\cf19 break};\par
00035     {\cf20 //green turrets}\par
00036     {\cf19 case} 1:\par
00037         sprite->setTexture((*spriteSheet));\par
00038         sprite->setTextureRect(sf::IntRect(48, 117, 30, 17));\par
00039 \par
00040         sprite->setPosition(translateTo2d(pos));\par
00041         sprite->setOrigin(sprite->getGlobalBounds().width / 2,\par
00042             sprite->getGlobalBounds().height / 2);\par
00043         {\cf19 break};\par
00044     {\cf20 //shooting up & red shooting up}\par
00045     {\cf19 case} 4:\par
00046     {\cf19 case} 2:\par
00047         spriteSheet = tex;\par
00048         setPos(pos + sf::Vector3f(-14, 0, 0));\par
00049         sprite->setTexture((*spriteSheet));\par
00050         sprite->setTextureRect(sf::IntRect(72, 69, 32, 30));\par
00051         sprite->setPosition(translateTo2d(pos));\par
00052         sprite->setOrigin(sf::Vector2f(sprite->getGlobalBounds().width / 2,\par
00053             sprite->getGlobalBounds().height / 2));\par
00054         rocketZ = delay;\par
00055 \par
00056         rocketExplosionSprite.setTexture(*spriteSheet);\par
00057         rocketExplosionSprite.setTextureRect(sf::IntRect(119, 71, 38, 27));\par
00058         rocketExplosionSprite.setPosition(\par
00059             translateTo2d(pos) + sf::Vector2f(0, 0));\par
00060         rocketExplosionSprite.setOrigin(sf::Vector2f(\par
00061             sprite->getGlobalBounds().width / 2,\par
00062             sprite->getGlobalBounds().height / 2));\par
00063         {\cf19 break};\par
00064     {\cf20 //right green turrets}\par
00065     {\cf19 case} 3:\par
00066         type = GREEN_CANNON_RIGHT;\par
00067         sprite->setTexture((*spriteSheet));\par
00068         sprite->setTextureRect(sf::IntRect(320, 153, 33, 22));\par
00069 \par
00070         sprite->setPosition(translateTo2d(pos));\par
00071         sprite->setOrigin(sprite->getGlobalBounds().width / 2,\par
00072             sprite->getGlobalBounds().height / 2);\par
00073         {\cf19 break};\par
00074     \}\par
00075 \par
00076     {\cf19 if} (dir == 4)\par
00077     \{\par
00078         redRocket = {\cf17 true};\par
00079         this->direction = 2;\par
00080         this->type = MISSILE_UP;\par
00081     \}\par
00082 \}\par
00083 \par
00084 \par
00091 Obstacle::Obstacle(sf::Vector3f pos, sf::Texture* tex, {\cf18 int} type) : Entity()\par
00092 \{\par
00093     {\cf20 /*}\par
00094 {\cf20     KEY}\par
00095 {\cf20     1 = gas can}\par
00096 {\cf20     2 = satellite}\par
00097 {\cf20     3 = plane}\par
00098 {\cf20     4 = blue space gas can}\par
00099 {\cf20     */}\par
00100 \par
00101     this->type = {\cf17 static_cast<}ObstacleType{\cf17 >}(type);\par
00102     direction = -1;\par
00103     setPos(pos);\par
00104     turret = {\cf17 false};\par
00105     spriteSheet = tex;\par
00106 \par
00107     sprite->setTexture((*spriteSheet));\par
00108 \par
00109     {\cf19 switch} (type)\par
00110     \{\par
00111     {\cf19 case} 1:\par
00112         sprite->setTextureRect(sf::IntRect(87, 106, 30, 30));\par
00113         {\cf19 break};\par
00114     {\cf19 case} 2:\par
00115         sprite->setTextureRect(sf::IntRect(129, 109, 24, 28));\par
00116         {\cf19 break};\par
00117     {\cf19 case} 3:\par
00118         this->type = PLANE;\par
00119         sprite->setTextureRect(sf::IntRect(92, 35, 29, 25));\par
00120         {\cf19 break};\par
00121     {\cf19 case} 4:\par
00122         this->type = SPACE_FUEL;\par
00123         sprite->setTextureRect(sf::IntRect(8, 195, 26, 29));\par
00124         {\cf19 break};\par
00125     \}\par
00126 \par
00127     sprite->setPosition(translateTo2d(pos));\par
00128     sprite->setOrigin(sprite->getGlobalBounds().width / 2,\par
00129                       sprite->getGlobalBounds().height / 2);\par
00130 \}\par
00131 \par
00132 \par
00136 Obstacle::~Obstacle()\par
00137 \{\par
00138     {\cf17 const} {\cf18 int} bulletsSize = bullets.size();\par
00139     {\cf19 for} ({\cf18 int} i = 0; i < bulletsSize; i++)\par
00140         {\cf17 delete} bullets[i];\par
00141 \}\par
00142 \par
00147 {\cf18 void} Obstacle::kill(Animation::Anim animation)\par
00148 \{\par
00149     {\cf19 if} (type == 5)\par
00150         animation = Animation::ALT_DEATH;\par
00151     animations.run(sprite, Animation::RESET);\par
00152     animations.run(sprite, animation, isTurret() ? scoreIndicator : 0);\par
00153 \};\par
00154 \par
00155 \par
00160 std::vector<sf::Vector3f> Obstacle::getBulletLocations()\par
00161 \{\par
00162     {\cf19 return} bulletPositions;\par
00163 \}\par
00164 \par
00165 \par
00170 {\cf18 void} Obstacle::update(sf::RenderWindow& window, {\cf18 int} playerZ, {\cf18 float} gameSpeed)\par
00171 \{\par
00172     {\cf20 //Checks if obstacle is on screen}\par
00173     {\cf19 if} (!getWindowViewRect(window).intersects(sprite->getGlobalBounds())\par
00174         || animations.getState() == 1)\par
00175     \{\par
00176         onScreen = {\cf17 false};\par
00177         {\cf19 return};\par
00178     \}\par
00179 \par
00180     onScreen = {\cf17 true};\par
00181     {\cf18 bool} rocketExplosion = playerZ <= -rocketZ, rocketFiring = playerZ <= -\par
00182              rocketZ - 50;\par
00183 \par
00184     {\cf20 //Shooting mechanics for bassic turrets}\par
00185     {\cf19 if} (turret == {\cf17 true} && direction != 2)\par
00186     \{\par
00187         {\cf20 //Creates bullets for grey cannons}\par
00188         {\cf19 if} (count % total == 0 && direction == 0 && animations.getState() == 0)\par
00189         \{\par
00190             bullets.push_back({\cf17 new} ObstacleBullet(\par
00191                 getPos(), spriteSheet, AbstractBullet::BulletType::zBullet));\par
00192             bulletPositions.push_back(getPos());\par
00193 \par
00194             total = (rand() % 250) + 75;\par
00195         \}\par
00196 \par
00197         {\cf20 //Creates bullets for green cannons}\par
00198         {\cf19 else} {\cf19 if} (count % total == 0 && (direction == 1 || direction == 3)\par
00199             && animations.getState() == 0)\par
00200         \{\par
00201             {\cf19 switch} (direction)\par
00202             \{\par
00203             {\cf19 case} 1:\par
00204                 bullets.push_back({\cf17 new} ObstacleBullet(\par
00205                     getPos(), spriteSheet,\par
00206                     AbstractBullet::BulletType::xBulletL));\par
00207                 {\cf19 break};\par
00208             {\cf19 case} 3:\par
00209                 bullets.push_back({\cf17 new} ObstacleBullet(\par
00210                     getPos(), spriteSheet,\par
00211                     AbstractBullet::BulletType::xBulletR));\par
00212                 {\cf19 break};\par
00213             {\cf19 default}:\par
00214                 {\cf19 break};\par
00215             \}\par
00216 \par
00217             bulletPositions.push_back(getPos());\par
00218 \par
00219             total = (rand() % 250) + 75;\par
00220         \}\par
00221     \}\par
00222     {\cf20 //Controls the firing of up shooting missiles which are delayed from shooting afer entering the screen}\par
00223     {\cf19 else} {\cf19 if} (direction == 2 && (animations.getState() == 0 || animations.\par
00224         getState() == 6 || animations.getState() == 7))\par
00225     \{\par
00226         {\cf19 if} (rocketFiring)\par
00227         \{\par
00228             {\cf20 //Is the animation of launch still starting if so reset it}\par
00229             {\cf19 if} (animations.getState() == 3)\par
00230                 animations.run(sprite, Animation::RESET);\par
00231 \par
00232             {\cf20 //is it below its explode height}\par
00233             {\cf19 if} (getPos().y > 70.f)\par
00234             \{\par
00235                 setPos(sf::Vector3f(getPos().x, getPos().y - 0.5f, getPos().z));\par
00236                 sprite->setPosition(translateTo2d(getPos()));\par
00237                 {\cf19 if} (animations.getState() == 0 || animations.getState() == 7)\par
00238                     animations.run(sprite, Animation::ROCKET_FLICKER,\par
00239                                    redRocket);\par
00240             \}\par
00241             {\cf19 else} {\cf19 if} (animations.getState() == 7)\par
00242                 kill(Animation::ALT_DEATH);\par
00243         \}\par
00244         {\cf19 else} {\cf19 if} (rocketExplosion &&\par
00245             rocketAnimation.getState() < 3\par
00246         )\par
00247             rocketAnimation.run(&rocketExplosionSprite, Animation::LAUNCH);\par
00248     \}\par
00249 \par
00250     {\cf20 //Gives bullets their direction}\par
00251     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < bullets.size(); i++)\par
00252     \{\par
00253         bulletPositions.at(i) = bullets.at(i)->getPos();\par
00254         bullets.at(i)->update(window, gameSpeed);\par
00255     \}\par
00256 \par
00257     {\cf20 //Offset position on death}\par
00258     {\cf19 if} (animations.getState() == 4 && !moved)\par
00259     \{\par
00260         moved = {\cf17 true};\par
00261         {\cf19 if} (isTurret())\par
00262             setPos(getPos() + sf::Vector3f(0, 0, 0));\par
00263         {\cf19 else}\par
00264             setPos(getPos() + sf::Vector3f(0, 15, 0));\par
00265     \}\par
00266     sprite->setPosition(translateTo2d(getPos()));\par
00267 \par
00268     {\cf19 if} (type != MISSILE_UP && (type != SPACE_FUEL || getPos().x < 15))\par
00269         window.draw(*sprite);\par
00270     {\cf19 if} (type == MISSILE_UP && rocketExplosion)\par
00271     \{\par
00272         {\cf19 if} (rocketFiring)\par
00273             window.draw(*sprite);\par
00274         {\cf19 if} (rocketAnimation.getState() != 4)\par
00275             window.draw(rocketExplosionSprite);\par
00276     \}\par
00277 \par
00278     count = (count + 1) % total;\par
00279 \par
00280     {\cf20 //Moves Blue Space Gas Cans}\par
00281     {\cf19 if} (type == SPACE_FUEL)\par
00282     \{\par
00283         setPos(sf::Vector3f(getPos().x + 1.f, getPos().y - 0.6f,\par
00284             getPos().z));\par
00285         sprite->setPosition(translateTo2d(sf::Vector3f(getPos().x + 1.f,\par
00286             getPos().y - 0.6f, getPos().z)));\par
00287     \}\par
00288 \par
00289 {\cf21 #ifndef NDEBUG}\par
00290     debugText.setString(std::to_string({\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().x)) + {\cf22 " "} +\par
00291         std::to_string({\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().y)) + {\cf22 " "} + std::to_string(\par
00292             {\cf17 static_cast<}{\cf18 int}{\cf17 >}(getPos().z))\par
00293         + {\cf22 " "} + std::to_string(animations.getState())\par
00294     );\par
00295     debugText.setPosition(sprite->getPosition());\par
00296     {\cf19 if} (drawDebugText)\par
00297         window.draw(debugText);\par
00298 {\cf21 #endif }{\cf20 // !NDEBUG}\par
00299 \}\par
00300 \par
00301 \par
00305 {\cf18 void} Obstacle::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00306 \{\par
00307     update(window, 0, gameSpeed);\par
00308 \}\par
00309 \par
00310 \par
00315 {\cf18 bool} Obstacle::isPresent()\par
00316 \{\par
00317     {\cf19 return} animations.getState() != 1 && animations.getState() != 2\par
00318         && animations.getState() != 4 && onScreen;\par
00319 \}\par
00320 \par
00321 \par
00326 {\cf18 bool} Obstacle::isTurret()\par
00327 \{\par
00328     {\cf19 return} getType() == 3 || getType() == 4\par
00329         || getType() == 8;\par
00330 \}\par
00331 \par
00332 \par
00337 {\cf18 void} Obstacle::bulletKill({\cf18 int} bullet)\par
00338 \{\par
00339     {\cf17 delete} bullets[bullet];\par
00340     bullets.erase(bullets.begin() + (bullet));\par
00341     bulletPositions.erase(bulletPositions.begin() + bullet);\par
00342 \}\par
00343 \par
00344 \par
00349 Obstacle::ObstacleType Obstacle::getType()\par
00350 \{\par
00351     {\cf19 return} type;\par
00352 \}\par
00353 \par
00354 \par
00359 {\cf18 int} Obstacle::getScore()\par
00360 \{\par
00361     {\cf18 int} score = 0;\par
00362 \par
00363     {\cf19 switch} (type)\par
00364     \{\par
00365     {\cf19 case} 1:\par
00366         score += 300;\par
00367         {\cf19 break};\par
00368     {\cf19 case} 2:\par
00369         score += 1000;\par
00370         {\cf19 break};\par
00371     {\cf19 case} 5:\par
00372         score += 150;\par
00373         {\cf19 break};\par
00374     {\cf19 case} 6:\par
00375         score += 100;\par
00376         {\cf19 break};\par
00377     {\cf19 case} 7:\par
00378         score += 300;\par
00379         {\cf19 break};\par
00380     {\cf19 default}:\par
00381         {\cf19 switch} (this->scoreIndicator)\par
00382         \{\par
00383         {\cf19 case} 1:\par
00384             score += 200;\par
00385             {\cf19 break};\par
00386         {\cf19 case} 2:\par
00387             score += 500;\par
00388             {\cf19 break};\par
00389         {\cf19 case} 3:\par
00390             score += 1000;\par
00391         \}\par
00392     \}\par
00393 \par
00394     {\cf19 return} score;\par
00395 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Obstacle/Obstacle.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Obstacle/Obstacle.h}
{\xe \v C:/Zaxxon/src/Obstacle/Obstacle.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <iostream>}\par
{\f2 #include <vector>}\par
{\f2 #include "Util/Util.h"}\par
{\f2 #include <time.h>}\par
{\f2 #include "Entity/Entity.h"}\par
{\f2 #include "Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Obstacle}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Still obstacles that spawn across the levels. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Obstacle.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Obstacle/Obstacle.h}
{\xe \v C:/Zaxxon/src/Obstacle/Obstacle.h}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include <vector>}\par
00005 {\cf21 #include "Util/Util.h"}\par
00006 {\cf21 #include <time.h>}\par
00007 {\cf21 #include "Entity/Entity.h"}\par
00008 {\cf21 #include "Entity/AbstractBullet/ObstacleBullet/ObstacleBullet.h"}\par
00009 \par
00010 \par
00014 {\cf17 class }Obstacle : {\cf17 public} Entity\par
00015 \{\par
00016 {\cf17 public}:\par
00017     {\cf20 /*}\par
00018 {\cf20     KEY}\par
00019 {\cf20     1 = gas can}\par
00020 {\cf20     2 = satellite}\par
00021 {\cf20     3 = grey cannon}\par
00022 {\cf20     4 = green cannon}\par
00023 {\cf20     5 = Shooting Up}\par
00024 {\cf20     6 = Plane}\par
00025 {\cf20     7 = blue floating gas can}\par
00026 {\cf20     8 = green shooting right}\par
00027 {\cf20     */}\par
00028 \par
00029     {\cf17 enum} ObstacleType\par
00030     \{\par
00031         GAS_CAN = 1,\par
00032         SATELLITE,\par
00033         GREY_CANNON,\par
00034         GREEN_CANNON,\par
00035         MISSILE_UP,\par
00036         PLANE,\par
00037         SPACE_FUEL,\par
00038         GREEN_CANNON_RIGHT\par
00039     \};\par
00040 \par
00041     {\cf20 //For shooting obstacles}\par
00042     Obstacle(sf::Vector3f, sf::Texture*, {\cf18 int}, {\cf18 int});\par
00043     {\cf20 //For standby obstacles}\par
00044     Obstacle(sf::Vector3f, sf::Texture*, {\cf18 int});\par
00045     ~Obstacle() {\cf17 override};\par
00046 \par
00047     std::vector<sf::Vector3f> getBulletLocations();\par
00048     {\cf18 void} update(sf::RenderWindow&, {\cf18 int} playerZ, {\cf18 float});\par
00049     {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) {\cf17 override};\par
00050     {\cf18 bool} isPresent();\par
00051     {\cf18 bool} isTurret();\par
00052 \par
00053     {\cf18 void} bulletKill({\cf18 int});\par
00054     ObstacleType getType();\par
00055     {\cf18 int} getScore();\par
00056 \par
00057     {\cf18 void} kill(Animation::Anim animation = Animation::CHARACTER_DEATH) {\cf17 override};\par
00058 {\cf17 private}:\par
00059     std::vector<ObstacleBullet*> bullets;\par
00060     std::vector<sf::Vector3f> bulletPositions;\par
00061     {\cf18 int} direction, count = 1, total = 100, scoreIndicator = 0;\par
00062     ObstacleType type;\par
00063     {\cf18 bool} turret = {\cf17 false}, onScreen = {\cf17 false}, moved = {\cf17 false}, redRocket = {\cf17 false};\par
00064     {\cf17 const} {\cf18 bool} drawDebugText = {\cf17 true};\par
00065     sf::Sprite rocketExplosionSprite;\par
00066     Animation rocketAnimation;\par
00067     {\cf18 int} rocketZ = 0;\par
00068 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Util/Util.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Util/Util.cpp}
{\xe \v C:/Zaxxon/src/Util/Util.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Util.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b translateTo2d} (sf::Vector3f in)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convert normal 2d coordinates to isometric coordinates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getWindowViewRect} (sf::RenderWindow &window)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Easily get the current view rectangle with translations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b zPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if main button is pressed, automatically gets rid of inputs that are a held key over first press. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b upPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if up is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b downPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if down is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b leftPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if left is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rightPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if right is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v downPressed\:Util.cpp}
{\xe \v Util.cpp\:downPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool downPressed ()}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if down is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 72} of file {\b Util.cpp}.}\par
}
{\xe \v getWindowViewRect\:Util.cpp}
{\xe \v Util.cpp\:getWindowViewRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect getWindowViewRect (sf::RenderWindow &  {\i window})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Easily get the current view rectangle with translations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Float rectangle\par
}}}{
Definition at line {\b 23} of file {\b Util.cpp}.}\par
}
{\xe \v leftPressed\:Util.cpp}
{\xe \v Util.cpp\:leftPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool leftPressed ()}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if left is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 84} of file {\b Util.cpp}.}\par
}
{\xe \v rightPressed\:Util.cpp}
{\xe \v Util.cpp\:rightPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool rightPressed ()}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if right is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 96} of file {\b Util.cpp}.}\par
}
{\xe \v translateTo2d\:Util.cpp}
{\xe \v Util.cpp\:translateTo2d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f translateTo2d (sf::Vector3f  {\i in})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convert normal 2d coordinates to isometric coordinates. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i in} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector of 2 floats\par
}}}{
Definition at line {\b 9} of file {\b Util.cpp}.}\par
}
{\xe \v upPressed\:Util.cpp}
{\xe \v Util.cpp\:upPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool upPressed ()}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if up is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 60} of file {\b Util.cpp}.}\par
}
{\xe \v zPressed\:Util.cpp}
{\xe \v Util.cpp\:zPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool zPressed ()}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if main button is pressed, automatically gets rid of inputs that are a held key over first press. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 39} of file {\b Util.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Util.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Util/Util.cpp}
{\xe \v C:/Zaxxon/src/Util/Util.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Util.h"}\par
00002 \par
00003 \par
00009 sf::Vector2f translateTo2d(sf::Vector3f in)\par
00010 \{\par
00011     {\cf18 float} x = -in.x * 0.6f + -in.z * 0.6f;\par
00012     {\cf18 float} y = in.y + -in.x * 0.3f + in.z * 0.3f;\par
00013 \par
00014     {\cf19 return} sf::Vector2f(x, y);\par
00015 \}\par
00016 \par
00017 \par
00023 sf::FloatRect getWindowViewRect(sf::RenderWindow& window)\par
00024 \{\par
00025     {\cf17 auto} wPos = sf::Vector2f(window.getView().getCenter().x\par
00026                              - (window.getView().getSize().x / 2),\par
00027                              window.getView().getCenter().y - (window.getView().\par
00028                                  getSize().y / 2));\par
00029     {\cf19 return} sf::FloatRect(wPos.x, wPos.y, window.getView().getSize().x,\par
00030                          window.getView().getSize().y);\par
00031 \}\par
00032 \par
00033 \par
00039 {\cf18 bool} zPressed()\par
00040 \{\par
00041     {\cf19 if} ((sf::Keyboard::isKeyPressed(sf::Keyboard::Z) ||\par
00042         sf::Joystick::isButtonPressed(0, 0)) && util_zPress)\par
00043     \{\par
00044         util_zPress = {\cf17 false};\par
00045         {\cf19 return} {\cf17 true};\par
00046     \}\par
00047     {\cf19 if} (!util_zPress && !(sf::Keyboard::isKeyPressed(sf::Keyboard::Z)\par
00048         || sf::Joystick::isButtonPressed(0, 0)))\par
00049         util_zPress = {\cf17 true};\par
00050 \par
00051     {\cf19 return} {\cf17 false};\par
00052 \}\par
00053 \par
00054 \par
00060 {\cf18 bool} upPressed()\par
00061 \{\par
00062     {\cf19 return} sf::Keyboard::isKeyPressed(sf::Keyboard::Up) ||\par
00063         sf::Joystick::getAxisPosition(0, sf::Joystick::Y) < -10;\par
00064 \}\par
00065 \par
00066 \par
00072 {\cf18 bool} downPressed()\par
00073 \{\par
00074     {\cf19 return} sf::Keyboard::isKeyPressed(sf::Keyboard::Down) ||\par
00075         sf::Joystick::getAxisPosition(0, sf::Joystick::Y) > 10;\par
00076 \}\par
00077 \par
00078 \par
00084 {\cf18 bool} leftPressed()\par
00085 \{\par
00086     {\cf19 return} sf::Keyboard::isKeyPressed(sf::Keyboard::Left) ||\par
00087         sf::Joystick::getAxisPosition(0, sf::Joystick::X) < -10;\par
00088 \}\par
00089 \par
00090 \par
00096 {\cf18 bool} rightPressed()\par
00097 \{\par
00098     {\cf19 return} sf::Keyboard::isKeyPressed(sf::Keyboard::Right) ||\par
00099         sf::Joystick::getAxisPosition(0, sf::Joystick::X) > 10;\par
00100 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Util/Util.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Util/Util.h}
{\xe \v C:/Zaxxon/src/Util/Util.h}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b translateTo2d} (sf::Vector3f)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convert normal 2d coordinates to isometric coordinates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getWindowViewRect} (sf::RenderWindow &)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Easily get the current view rectangle with translations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b zPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if main button is pressed, automatically gets rid of inputs that are a held key over first press. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b upPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if up is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b downPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if down is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b leftPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if left is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b rightPressed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if right is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v downPressed\:Util.h}
{\xe \v Util.h\:downPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool downPressed ()}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if down is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 72} of file {\b Util.cpp}.}\par
}
{\xe \v getWindowViewRect\:Util.h}
{\xe \v Util.h\:getWindowViewRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect getWindowViewRect (sf::RenderWindow &  {\i window})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Easily get the current view rectangle with translations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Float rectangle\par
}}}{
Definition at line {\b 23} of file {\b Util.cpp}.}\par
}
{\xe \v leftPressed\:Util.h}
{\xe \v Util.h\:leftPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool leftPressed ()}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if left is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 84} of file {\b Util.cpp}.}\par
}
{\xe \v rightPressed\:Util.h}
{\xe \v Util.h\:rightPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool rightPressed ()}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if right is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 96} of file {\b Util.cpp}.}\par
}
{\xe \v translateTo2d\:Util.h}
{\xe \v Util.h\:translateTo2d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f translateTo2d (sf::Vector3f  {\i in})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Convert normal 2d coordinates to isometric coordinates. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i in} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Vector of 2 floats\par
}}}{
Definition at line {\b 9} of file {\b Util.cpp}.}\par
}
{\xe \v upPressed\:Util.h}
{\xe \v Util.h\:upPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool upPressed ()}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if up is current pressed, will handle both keyboard and controller. This will consider holding the stick in this direction as constant 'presses'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 60} of file {\b Util.cpp}.}\par
}
{\xe \v zPressed\:Util.h}
{\xe \v Util.h\:zPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool zPressed ()}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detects if main button is pressed, automatically gets rid of inputs that are a held key over first press. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A boolean\par
}}}{
Definition at line {\b 39} of file {\b Util.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Util.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Util/Util.h}
{\xe \v C:/Zaxxon/src/Util/Util.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 \par
00004 \par
00005 {\cf20 // Util contains helpful methods that are used in many places around the project.}\par
00006 sf::Vector2f translateTo2d(sf::Vector3f);\par
00007 sf::FloatRect getWindowViewRect(sf::RenderWindow&);\par
00008 \par
00009 {\cf17 static} {\cf18 bool} util_zPress = {\cf17 true};\par
00010 {\cf18 bool} zPressed();\par
00011 {\cf18 bool} upPressed();\par
00012 {\cf18 bool} downPressed();\par
00013 {\cf18 bool} leftPressed();\par
00014 {\cf18 bool} rightPressed();\par
00015 sf::FloatRect getWindowViewRect(sf::RenderWindow&);\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Wall/Wall.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Wall/Wall.cpp}
{\xe \v C:/Zaxxon/src/Wall/Wall.cpp}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Wall.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wall.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Wall/Wall.cpp}
{\xe \v C:/Zaxxon/src/Wall/Wall.cpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Wall.h"}\par
00002 \par
00003 \par
00011 Wall::Wall(sf::Texture* tex, sf::Vector3f pos, {\cf18 int} size, std::vector<int> walls)\par
00012 \{\par
00013     spriteSheet = tex;\par
00014 \par
00015     {\cf20 /*}\par
00016 {\cf20     KEY for Vector}\par
00017 {\cf20     0 = closed wall piece}\par
00018 {\cf20     1 = open wall piece}\par
00019 {\cf20     */}\par
00020 \par
00021     {\cf19 for} ({\cf18 int} i = 0; i < size; i++)\par
00022     \{\par
00023         sprites.push_back(sf::Sprite());\par
00024         sprites.at(i).setTexture(*spriteSheet);\par
00025         sprites.at(i).setPosition(\par
00026             translateTo2d(sf::Vector3f(pos.x - 38 * i, pos.y, pos.z)));\par
00027         wallPositions.push_back(sf::Vector3f(pos.x - 38 * i, pos.y, pos.z));\par
00028 \par
00029         {\cf19 if} (walls.at(i) == 0)\par
00030             sprites.at(i).setTextureRect(sf::IntRect(240, 64, 33, 31));\par
00031         {\cf19 else}\par
00032             sprites.at(i).setTextureRect(sf::IntRect(279, 64, 33, 31));\par
00033     \}\par
00034 \}\par
00035 \par
00036 \par
00041 {\cf18 void} Wall::drawWalls(sf::RenderWindow& window)\par
00042 \{\par
00043     {\cf19 if} (!getWindowViewRect(window).intersects(\par
00044             sprites.at(sprites.size() - 1).getGlobalBounds()) &&\par
00045         !getWindowViewRect(window).intersects(sprites.at(0).getGlobalBounds()))\par
00046     \{\par
00047         onScreen = {\cf17 false};\par
00048         {\cf19 return};\par
00049     \}\par
00050 \par
00051     onScreen = {\cf17 true};\par
00052 \par
00053     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < sprites.size(); i++)\par
00054         window.draw(sprites.at(i));\par
00055 \}\par
00056 \par
00057 \par
00063 {\cf18 void} Wall::setPosition(sf::Vector3f pos, {\cf18 int} piece)\par
00064 \{\par
00065     sprites.at(piece).setPosition(translateTo2d(pos));\par
00066     wallPositions.at(piece) = pos;\par
00067 \}\par
00068 \par
00069 \par
00075 {\cf18 void} Wall::setTexture({\cf18 int} piece, {\cf18 int} tex)\par
00076 \{\par
00077     {\cf20 //Closed Piece}\par
00078     {\cf19 if} (tex == 0)\par
00079         sprites.at(piece).setTextureRect(sf::IntRect(240, 64, 34, 32));\par
00080 \par
00081     {\cf20 //Open Piece}\par
00082     {\cf19 if} (tex == 1)\par
00083         sprites.at(piece).setTextureRect(sf::IntRect(278, 65, 34, 32));\par
00084 \}\par
00085 \par
00086 \par
00091 {\cf18 bool} Wall::checkOnScreen()\par
00092 \{\par
00093     {\cf19 return} onScreen;\par
00094 \}\par
00095 \par
00096 \par
00101 std::vector<sf::Vector3f>& Wall::getWallPositions()\par
00102 \{\par
00103     {\cf19 return} wallPositions;\par
00104 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Wall/Wall.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Wall/Wall.h}
{\xe \v C:/Zaxxon/src/Wall/Wall.h}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <vector>}\par
{\f2 #include "Util/Util.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Wall}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for the normal walls (stone brick). }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Wall.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Wall/Wall.h}
{\xe \v C:/Zaxxon/src/Wall/Wall.h}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 {\cf21 #include <vector>}\par
00004 {\cf21 #include "Util/Util.h"}\par
00005 \par
00006 \par
00010 {\cf17 class }Wall\par
00011 \{\par
00012 {\cf17 public}:\par
00013     Wall(sf::Texture*, sf::Vector3f, {\cf18 int} size, std::vector<int>);\par
00014 \par
00015     {\cf18 void} drawWalls(sf::RenderWindow& window);\par
00016     {\cf18 void} setPosition(sf::Vector3f, {\cf18 int} piece = 0);\par
00017     {\cf18 void} setTexture({\cf18 int}, {\cf18 int});\par
00018     {\cf18 bool} checkOnScreen();\par
00019     std::vector<sf::Vector3f>& getWallPositions();\par
00020 {\cf17 private}:\par
00021     sf::Texture* spriteSheet;\par
00022     {\cf18 bool} onScreen = {\cf17 false};\par
00023     std::vector<sf::Sprite> sprites;\par
00024     std::vector<sf::Vector3f> wallPositions;\par
00025 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/ZapWall/ZapWall.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/ZapWall/ZapWall.cpp}
{\xe \v C:/Zaxxon/src/ZapWall/ZapWall.cpp}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ZapWall.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZapWall.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/ZapWall/ZapWall.cpp}
{\xe \v C:/Zaxxon/src/ZapWall/ZapWall.cpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ZapWall.h"}\par
00002 \par
00003 \par
00009 ZapWall::ZapWall(sf::Texture* tex, sf::Vector3f pos)\par
00010 \{\par
00011     spriteSheet = tex;\par
00012     startPosition = pos;\par
00013     setPos(pos);\par
00014 \par
00015     sprite->setTexture(*spriteSheet);\par
00016     sprite->setPosition(translateTo2d(sf::Vector3f(pos.x, pos.y, pos.z)));\par
00017     sprite->setTextureRect(sf::IntRect(199, 63, 35, 35));\par
00018 \}\par
00019 \par
00020 \par
00026 {\cf18 void} ZapWall::update(sf::RenderWindow& window, {\cf18 float} gameSpeed)\par
00027 \{\par
00028     {\cf20 //Only draws if on screen and has delay so it does not stop too early}\par
00029     {\cf19 if} (!getWindowViewRect(window).intersects(sprite->getGlobalBounds()))\par
00030     \{\par
00031         {\cf19 if} (drawn == {\cf17 true})\par
00032             offScreenCount++;\par
00033 \par
00034         {\cf19 if} (offScreenCount == 15)\par
00035         \{\par
00036             offScreenCount = 15;\par
00037             onScreen = {\cf17 false};\par
00038             drawn = {\cf17 false};\par
00039             {\cf19 return};\par
00040         \}\par
00041     \}\par
00042 \par
00043     onScreen = {\cf17 true};\par
00044     drawn = {\cf17 true};\par
00045 \par
00046     window.draw(*sprite);\par
00047 \par
00048     {\cf20 //Movement every two frames}\par
00049     {\cf19 if} (count == 2)\par
00050     \{\par
00051         {\cf20 //If on screen, move it over}\par
00052         {\cf19 if} (getPos().x > -190)\par
00053         \{\par
00054             sprite->move(translateTo2d(sf::Vector3f(-58, 0, 0)));\par
00055             setPos(sf::Vector3f(getPos().x - 58, getPos().y, getPos().z));\par
00056         \}\par
00057         {\cf20 //else it is off screen, reset it to start position}\par
00058         {\cf19 else}\par
00059         \{\par
00060             sprite->setPosition(translateTo2d(sf::Vector3f(startPosition)));\par
00061             setPos(startPosition);\par
00062         \}\par
00063         count = 0;\par
00064     \}\par
00065     {\cf19 else}\par
00066         count++;\par
00067 \}\par
00068 \par
00069 \par
00073 {\cf18 void} ZapWall::setStartPos(sf::Vector3f pos)\par
00074 \{\par
00075     startPosition = pos;\par
00076 \}\par
00077 \par
00078 \par
00083 {\cf18 bool} ZapWall::isOnScreen()\par
00084 \{\par
00085     {\cf19 return} onScreen;\par
00086 \}\par
00087 \par
00088 \par
00093 sf::Vector3f ZapWall::getStartPosition()\par
00094 \{\par
00095     {\cf19 return} startPosition;\par
00096 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/ZapWall/ZapWall.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/ZapWall/ZapWall.h}
{\xe \v C:/Zaxxon/src/ZapWall/ZapWall.h}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include "Util/Util.h"}\par
{\f2 #include "Entity/Entity.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ZapWall}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for other walls (blue lightning). }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZapWall.h\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/ZapWall/ZapWall.h}
{\xe \v C:/Zaxxon/src/ZapWall/ZapWall.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 {\cf21 #include <SFML/Graphics.hpp>}\par
00003 {\cf21 #include "Util/Util.h"}\par
00004 {\cf21 #include "Entity/Entity.h"}\par
00005 \par
00006 \par
00010 {\cf17 class }ZapWall : {\cf17 public} Entity\par
00011 \{\par
00012 {\cf17 public}:\par
00013     ZapWall(sf::Texture*, sf::Vector3f);\par
00014 \par
00015     {\cf18 void} update(sf::RenderWindow&, {\cf18 float}) {\cf17 override};\par
00016 \par
00017     {\cf18 void} setStartPos(sf::Vector3f pos);\par
00018     {\cf18 bool} isOnScreen();\par
00019     sf::Vector3f getStartPosition();\par
00020 {\cf17 private}:\par
00021     {\cf18 bool} onScreen = {\cf17 false};\par
00022     sf::Vector3f startPosition;\par
00023     {\cf18 int} count = 0;\par
00024     {\cf18 int} offScreenCount = 0;\par
00025     {\cf18 bool} drawn = {\cf17 false};\par
00026 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Zaxxon/src/Zaxxon.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Zaxxon.cpp}
{\xe \v C:/Zaxxon/src/Zaxxon.cpp}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include "Game/Game.h"}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:Zaxxon.cpp}
{\xe \v Zaxxon.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b Zaxxon.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zaxxon.cpp\par \pard\plain 
{\tc\tcl2 \v C:/Zaxxon/src/Zaxxon.cpp}
{\xe \v C:/Zaxxon/src/Zaxxon.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20 * Time of development:}\par
00003 {\cf20 * Jan 29 - May 8 2024}\par
00004 {\cf20 *}\par
00005 {\cf20 * Developer team:}\par
00006 {\cf20 * Gavin - Team leader / Programmer}\par
00007 {\cf20 * Alex - Administrator / Language lawyer}\par
00008 {\cf20 * Andrew - Chief programmer}\par
00009 {\cf20 * John - Copilot / Tester}\par
00010 {\cf20 *}\par
00011 {\cf20 * Program:}\par
00012 {\cf20 * Recreation of the popular Zaxxon Sega arcade game in C++.}\par
00013 {\cf20 * An easy way to enjoy the classic game with optimized performance}\par
00014 {\cf20 * and memory usage, with all the features as you'd expect.}\par
00015 {\cf20 * }\par
00016 {\cf20 * Controls:}\par
00017 {\cf20 * Keyboard: Arrow keys and Z}\par
00018 {\cf20 * Joystick: Stick0 and button0}\par
00019 {\cf20 *}\par
00020 {\cf20 * We hereby certify that this program represents our}\par
00021 {\cf20 * work and that the design and logic was completed}\par
00022 {\cf20 * without outside assistance.}\par
00023 {\cf20 */}\par
00024 \par
00025 {\cf21 #include <SFML/Graphics.hpp>}\par
00026 {\cf21 #include "Game/Game.h"}\par
00027 {\cf21 #include <iostream>}\par
00028 \par
00029 \par
00030 {\cf18 int} main()\par
00031 \{\par
00032     {\cf20 // Startup Zaxxon}\par
00033     {\cf17 auto} game = {\cf17 new} Game();\par
00034     game->run();\par
00035 \par
00036     {\cf20 // Game finished, remove it from memory}\par
00037     {\cf17 delete} game;\par
00038 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
